/*******************************************************************************************************************************
 * Tri2ModelValidator.java Copyright ï¿½ 2012, Triniti Corporation. All rights
 * reserved. The Programs (which include both the software and documentation)
 * contain proprietary information of Triniti Corporation; they are provided
 * under a license agreement containing restrictions on use and disclosure and
 * are also protected by copyright, patent and other intellectual and industrial
 * property law. Reverse engineering, disassembly or de-compilation of the
 * programs is prohibited. Program Documentation is licensed for use solely to
 * support the deployment of the Programs and not for any other purpose. The
 * information contained in this document is subject to change without notice.
 * If you find any problems in the documentation, please report them to us in
 * writing. Triniti Corporation does not warrant that this document is error
 * free. Except as may be expressly permitted in your license agreement for
 * these Programs, no part of these Programs may be reproduced or transmitted in
 * any form or by any means, electronic or mechanical, for any purpose, without
 * the express written permission of Triniti Corporation. Author : Sayantan Roy
 * Date : Dec 17, 2012 Last modified by : Sayantan Roy Last modified on : Dec
 * 17, 2012
 *******************************************************************************************************************************/

package gps.validateModels.tri2issues;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.Vector;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.http.HttpStatus;
import org.jsoup.Jsoup;

import com.sun.org.apache.bcel.internal.classfile.Constant;
import com.triniti.tri2.TRI2Utils;
import com.triniti.utils.ObjectPool;

import eDynamo.classes.tri2.SG_TRI2_CLOUD_SETUP_MAPPED_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_COPY_MAPPED_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_CVS_MAPPED_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_ENTITY;
import eDynamo.classes.tri2.SG_TRI2_Fetch_MAPPED_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_GIT_MAPPED_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_MIGRATION_DETAILS;
import eDynamo.classes.tri2.SG_TRI2_MIG_AOL_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_MIG_ICS_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_MIG_INFORMATICA_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_MIG_PROPERTIES_OBJECTS;
import eDynamo.classes.tri2.SG_TRI2_MIG_SQL_EXPORT;
import eDynamo.classes.tri2.SG_TRI2_ORA_DISC_EXPORT;
import eDynamo.classes.tri2.SG_TRI2_PREDECESSOR_ISSUE;
import eDynamo.classes.tri2.SG_TRI2_SVN_MAPPED_OBJECTS;
import eDynamo.code.tri2migration.TrinitiJavaCode_MIG_SOLUTION_OBJECTS_R2O;
import gps.build.ModelValidator;
import gps.core.GPSModel;
import gps.core.HierarchyModel;
import gps.core.HierarchyNode;
import gps.tools.ResourceBundleUtils;
import helpers.ConnectionHelper.ConnectionRepositoryHelper;
import helpers.migrationRequest.migration.ObjectTypeConfigurationThreads;
import triniti.data.DataHandler;
import triniti.service.helper.FunctionHelper;

/**
 * Class Tri2ModelValidator
 */
public class Tri2ModelValidator extends ModelValidator
{
    private static final String cvsVersion = "$Id: Tri2ModelValidator.java,v 1.105 2024/03/12 04:55:57 rohit.sharma Exp $";
    
    private StringBuffer msg;

    boolean returnFlag = true;
    boolean isSolutionObjectAttached = false;
    boolean isTicketAvailableInCopyObjects = false;
    boolean atleastOneMigrateFlagChecked = false;
    
    int fetchMappedObjectsArrayLength = 0;
    //IS115065 - Implement Object locking feature in AOM while mapping the objects from source environment.
    Connection connection;
   
    DataHandler dataHandler = null;
    

    /**
     * Default constructor. Creating the Warning messageBuffer, at the time of
     * Instantiation. S.ROY on 19th Dec, 12.
     */
    public Tri2ModelValidator()
    {
        super();
        msg = ObjectPool.getStringBuffer();
        if(msg == null)
        {
            msg = new StringBuffer(50);
        }
    }

    /**
     * Implemented from ModelValidator class
     * 
     * @param gpsmodel
     *            This method will be called by default.
     */
    public boolean validateModel(GPSModel gpsmodel, Integer integer, String s)
    {
        HierarchyModel valHModel = (HierarchyModel) gpsmodel;
        HierarchyNode valHNode = (HierarchyNode) valHModel.getRootNode();
        if(valHNode != null)
        {
            SG_TRI2_ENTITY migrationRequestBean = (SG_TRI2_ENTITY) valHNode.getUserObject();
            System.out.println("Tri2ModelValidator.validateModel()...calling startValidationProcess() method.");
            try
            {
            	//IS125797 - Changes in the solution objects should happen only when the ticket is available in the respective objects mapping state.
            	if(isTicketMovedFromAttachSolutionState(migrationRequestBean)) 
            	{
            		returnFlag = false;
            	}
            	else
            	{
            		returnFlag = this.startValidationProcess(migrationRequestBean);
//            		SG_TRI2_CVS_MAPPED_OBJECTS[] objectsBeanArray = migrationRequestBean.getSG_TRI2_CVS_MAPPED_OBJECTS();
//            		SG_TRI2_CVS_MAPPED_OBJECTS beanObj = null;
//            		 if(objectsBeanArray != null && objectsBeanArray.length > 0)
//                     {
//                         int objectsBeanArraylength = objectsBeanArray.length;
//                         for(int objectsBeanIndex = 0; objectsBeanIndex < objectsBeanArraylength; objectsBeanIndex ++ )
//                         {
//                        	 beanObj = new SG_TRI2_CVS_MAPPED_OBJECTS();
//                             beanObj = objectsBeanArray[objectsBeanIndex];
//                             if(beanObj.getMIG_FORM_APPLICATION_TOP() != null || beanObj.getMIG_APPL_SHORT_NAME() != null)
//                             {
//                            	 System.out.println("Tri2ModelValidator.validateModel()..getMIG_FORM_APPLICATION_TOP :- " +beanObj.getMIG_FORM_APPLICATION_TOP());
//                            	 System.out.println("Tri2ModelValidator.validateModel()..getMIG_APPL_SHORT_NAME() :- " +beanObj.getMIG_APPL_SHORT_NAME());
//
//                             }
//                         }
//                     }
          	}
                
            }
            catch(Exception e)
            {
                System.out.println("Tri2ModelValidator.validateModel()....Exception:" + e);
                e.printStackTrace();
            }
        }
        System.out.println("Tri2ModelValidator.validateModel()...returnFlag: " + returnFlag);
        return returnFlag;
    }
    
    //IS125797 - Changes in the solution objects should happen only when the ticket is available in the respective objects mapping state.
    public boolean isTicketMovedFromAttachSolutionState(SG_TRI2_ENTITY migrationRequestBean)
    {
    	System.out.println("Tri2ModelValidator.validateModel()...calling isTicketMovedFromAttachSolutionState() method.");
    	boolean flag = false;
    	Object issueNumberFromBean = migrationRequestBean.getIA_ISSUE_NUMBER();
    	System.out.println("Tri2ModelValidator.isTicketMovedFromAttachSolutionState() ....issueNumberFromBean :: "+issueNumberFromBean);
    	String stateForSolutionObject = TRI2Utils.getTRI2PropertyValue("state_for_solution_objects_attached");
    	System.out.println("Tri2ModelValidator.isTicketMovedFromAttachSolutionState() ....stateForSolutionObject :: "+stateForSolutionObject);
    	if(issueNumberFromBean != null )
    	{
    		String ticketStatus = null;
    		String stateType = null;
    		Object[] dataList			= null;
    		Object[] columnArray		= null;
    		String etkUrl				= null;
    		String whereCondition		= null;
    		Vector valueVector			= null;
    		try
    		{
    			valueVector     = ObjectPool.getVector();
    			etkUrl = ResourceBundleUtils.getString("ContextPath", "etkurl");
    			if(etkUrl != null && etkUrl.trim().length() > 0)
    			{
    				dataHandler		= new DataHandler(etkUrl);
    				whereCondition 	= "ISSUES.ISSUE_NUMBER = ?";

    				valueVector.add(issueNumberFromBean);
    				valueVector.add("java.lang.String");
    				dataList	= dataHandler.getDataFromETK("code.ISSUES_BY_ME.TrinitiJavaCode_ISSUES_BY_ME_R2O", whereCondition, valueVector);
    				columnArray = dataHandler.getColumns();
    				if(dataList != null && dataList.length > 0 && columnArray != null && columnArray.length > 0)
    				{
    					java.util.List columnList	= Arrays.asList(columnArray);
    					int ticketStatusIndex	= columnList.indexOf("STATE_NAME");
    					int stateTypeIndex	= columnList.indexOf("STATE_TYPE");
    					Object[] dataValueArray		= (Object[]) dataList[0];
    					ticketStatus = (String) dataValueArray[ticketStatusIndex];
    					stateType = (String) dataValueArray[stateTypeIndex];
    					System.out.println("ticketStatus :: "+ticketStatus);
    					if(!stateForSolutionObject.equalsIgnoreCase(stateType))
    					{

    						msg.append("It is not allowed to save the object, once the ticket moved from the attach/mapping objects state.");
    						msg.append("\nNow its available at "+ticketStatus+" state");
    						System.out.println("The ticket is already moved from Develop, Test and Map Objects state."+" Now its available at "+ticketStatus);
    						flag = true;
    					}


    				}
    				else
    				{

    					System.out.println("DataList is Null");
    				}		
    			}
    			else
    			{
    				System.out.println("EtkUrl is Null");
    			}
    		}
    		catch(Throwable ex)
    		{
    			System.out.println(ex);
    		}
    		finally
    		{
    			if(valueVector != null)
    			{
    				ObjectPool.freeVector(valueVector);	
    			}
    		}
    	}
    	System.out.println("Flag ::"+flag);
    	return flag;
    }

    /*
     * (non-Javadoc)
     * @see gps.build.ModelValidator#getDataVector() Dummy method with No
     * Implementation. !!
     */
    public Vector getDataVector()
    {
        // TODO Auto-generated method stub
        return null;
    }

    /*
     * (non-Javadoc)
     * @see gps.build.ModelValidator#getNodeNameAndNodeHashtable() Dummy method
     * with no implementation !!
     */
    public Hashtable getNodeNameAndNodeHashtable()
    {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * @author S.ROY
     * @since 19th Dec, 12.
     * @param migrationRequestBean
     * @return {@link Boolean}
     * @throws NullPointerException
     * @throws StringIndexOutOfBoundsException
     * @throws ArrayIndexOutOfBoundsException
     * @throws Exception
     *             This will start the client side validation process, for all
     *             the different types of Object.
     */
    List<Double> deadLockOccurredList = new ArrayList<Double>();
    private boolean startValidationProcess(SG_TRI2_ENTITY migrationRequestBean) throws NullPointerException, StringIndexOutOfBoundsException, ArrayIndexOutOfBoundsException, Exception
    {
        System.out.println("Tri2ModelValidator.startValidationProcess()...is in Execution!");
        ResourceBundle applicationPropsURL = ResourceBundle.getBundle("applicationurl", Locale.getDefault());
        String validateExtractFile = applicationPropsURL.getString("validateExtractFile");
        
        SG_TRI2_MIGRATION_DETAILS beanObj = null;
        SG_TRI2_CVS_MAPPED_OBJECTS cvsMappedBeanObj = null;
        SG_TRI2_SVN_MAPPED_OBJECTS svnMappedBeanObj = null;
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        SG_TRI2_GIT_MAPPED_OBJECTS gitMappedBeanObj = null;
        
        SG_TRI2_MIGRATION_DETAILS[] migDetails = migrationRequestBean.getSG_TRI2_MIGRATION_DETAILS();
        SG_TRI2_CVS_MAPPED_OBJECTS[] cvsMappedMigDetails = migrationRequestBean.getSG_TRI2_CVS_MAPPED_OBJECTS();
        SG_TRI2_SVN_MAPPED_OBJECTS[] svnMappedMigDetails = migrationRequestBean.getSG_TRI2_SVN_MAPPED_OBJECTS();
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        SG_TRI2_GIT_MAPPED_OBJECTS[] gitMappedMigDetails = migrationRequestBean.getSG_TRI2_GIT_MAPPED_OBJECTS();
        SG_TRI2_COPY_MAPPED_OBJECTS[] copyMappedObjectsArray = migrationRequestBean.getSG_TRI2_COPY_MAPPED_OBJECTS();
        /*
         * IS083433 - Provision to map DB objects from source instance 
         * (which will be checked-in to configured path in repository) and
         *  migrate to required target instance
         */
        SG_TRI2_MIG_SQL_EXPORT[] mapSqlObjectsArray = migrationRequestBean.getSG_TRI2_MIG_SQL_EXPORT();
        /*
         *IS083721:Option to map discoverer objects from source instance,
         *check-in to repository in a configured path and migrate to 
         *required target instance.
         */
        SG_TRI2_ORA_DISC_EXPORT[] mapOraDiscObjectsArray = migrationRequestBean.getSG_TRI2_ORA_DISC_EXPORT();

        /**
         * IS083081 - Option to map AOL objects from source instance, check-in to repository in a configured path and migrate to required target instance
         */
        SG_TRI2_MIG_AOL_OBJECTS[] mapAOLObjectsArray = migrationRequestBean.getSG_TRI2_MIG_AOL_OBJECTS();
        
        SG_TRI2_MIG_INFORMATICA_OBJECTS[] mapInformaticaObjectsArray = migrationRequestBean.getSG_TRI2_MIG_INFORMATICA_OBJECTS();
        SG_TRI2_MIG_ICS_OBJECTS[] mapICSObjectsArray = migrationRequestBean.getSG_TRI2_MIG_ICS_OBJECTS();
        /***
         * IS114427 - AOM to support multiple Oracle cloud setup objects mapping with in a single migration request.
         * To Map the Cloud Setup Objects
         */
        SG_TRI2_CLOUD_SETUP_MAPPED_OBJECTS cloudSetupMappedBeanObj = null;
        SG_TRI2_CLOUD_SETUP_MAPPED_OBJECTS[] mapCloudSetupObjectsArray = migrationRequestBean.getSG_TRI2_CLOUD_SETUP_MAPPED_OBJECTS();
        
        int lengthOfMigDetailsBeanArr   = 0;
        int lengthOfCvsMappedObjBeanArr = 0;
        int lengthOfSvnMappedObjBeanArr = 0;
        
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        int lengthOfGitMappedObjBeanArr = 0;
        /*
         * IS083433 - Provision to map DB objects from source instance 
         * (which will be checked-in to configured path in repository) and
         *  migrate to required target instance
         */
        int lengthOfMapSqlObjBeanArray = 0;
        int lengthOfOraDiscObjBeanArray = 0;
        
        /**
         * IS083081 - Option to map AOL objects from source instance, check-in to repository in a configured path and migrate to required target instance
         */
        int lengthOfMapAOLObjectsBeanArray = 0;
        int lengthOfmapInformaticaObjectsArray = 0;
        int lengthOfmapICSObjectsArray = 0;
        /***
         * IS114427 - AOM to support multiple Oracle cloud setup objects mapping with in a single migration request.
         * To Map the Cloud Setup Objects
         */
        int lengthOfMapCloudSetupObjectsArray = 0;
        
        boolean isObjectAvailable = false;
        boolean isAtleastOneObjectModified = false;
        //IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
        ArrayList solutionObjectIdList = new ArrayList();
        ArrayList previousSolutionObjectIdList = migrationRequestBean.getSolutionObjectIDList();
        ArrayList previousPredecessorIssuesList = migrationRequestBean.getPredecessorsIssuesList();

        if(migDetails != null)
        {
            lengthOfMigDetailsBeanArr = migDetails.length;
        }
        if(cvsMappedMigDetails != null)
        {
            lengthOfCvsMappedObjBeanArr = cvsMappedMigDetails.length;
        }
        if(svnMappedMigDetails != null)
        {
            lengthOfSvnMappedObjBeanArr = svnMappedMigDetails.length;
        }
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        if(gitMappedMigDetails != null)
        {
        	lengthOfGitMappedObjBeanArr = gitMappedMigDetails.length;
        }
        
        /**
         * IS083081 - Option to map AOL objects from source instance, check-in to repository in a configured path and migrate to required target instance
         */
        if(mapAOLObjectsArray != null)
        {
            lengthOfMapAOLObjectsBeanArray = mapAOLObjectsArray.length;
        }
        
        if(mapInformaticaObjectsArray != null)
        {
            lengthOfmapInformaticaObjectsArray = mapInformaticaObjectsArray.length;
        }
        if(mapICSObjectsArray != null)
        {
            lengthOfmapICSObjectsArray = mapICSObjectsArray.length;
        }
        /*
         * IS083433 - Provision to map DB objects from source instance 
         * (which will be checked-in to configured path in repository) and
         *  migrate to required target instance
         */
        if(mapSqlObjectsArray != null)
        {
            lengthOfMapSqlObjBeanArray = mapSqlObjectsArray.length;
        }
        if(mapOraDiscObjectsArray != null)
        {
            lengthOfOraDiscObjBeanArray = mapOraDiscObjectsArray.length;
        }
        /***
         * IS114427 - AOM to support multiple Oracle cloud setup objects mapping with in a single migration request.
         * To Map the Cloud Setup Objects
         */
        if(mapCloudSetupObjectsArray != null)
        {
        	lengthOfMapCloudSetupObjectsArray = mapCloudSetupObjectsArray.length;
        }
        
        LinkedHashMap allSQLObjectsDataMap = new LinkedHashMap();
        /**
         * IS080795 Validation of Oracle objects in TRI2 Migration Tool based on editioned/non-editioned 
         * if Target instance is configured for Online Patching migrations
         */
        LinkedHashMap allOtherObjectsExceptSQL = new LinkedHashMap();

        /**
         * IS079556-Need to parse each mapped object to a ticket, validate and store status of each object against 
         * Database Compliance Checker Report(DBCC) of target instance
         * Getting previous target instance and holding to violate against DBCC
         */
        String sourceInstanceName = migrationRequestBean.getSOURCE_INSTANCE_NAME();
        
        String isOnlinePatchingEnabledForTargetInstance = (String) migrationRequestBean.getIsOnlinePatchingEnabledForTargetInstance();
        
        boolean isOnlinePatchingEnabledForTargetInstanceFlag = Boolean.valueOf(isOnlinePatchingEnabledForTargetInstance);
        /**
         * IS089199- Provide an option for database type(Oracle/Postgre) at object level while attaching/mapping SQL objects and migration should 
         * happen based on the target instance's database type(ignoring other objects of different database type)
         */
        boolean validateDatabaseType = Boolean.valueOf(migrationRequestBean.getValidateDatabaseType());
        
        System.out.println("Tri2ModelValidator.startValidationProcess()...isOnlinePatchingEnabledForTargetInstance:" + isOnlinePatchingEnabledForTargetInstance
        		+ ", isOnlinePatchingEnabledForTargetInstanceFlag:" + isOnlinePatchingEnabledForTargetInstanceFlag + ", validateDatabaseType:" + validateDatabaseType);
        
        /**
         * IS090169 - Provide depend on feature for migrations in AOM
         */
        ArrayList<Double> migrationSequences = new ArrayList<Double>();
        ArrayList<String> dependOns = new ArrayList<String>();
        
        /**
         * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
         */
        
        ArrayList<Double> onSuccesses = new ArrayList<Double>();
        ArrayList<Double> onFailures = new ArrayList<Double>();
        HashMap successMap = new HashMap();
		HashMap failureMap = new HashMap();
        
        Double onSuccess = null;
        Double onFailure = null;
       
        Double migrationSequence = null;
        String dependOn = null;
        String issueNumber =  (String) migrationRequestBean.getIA_ISSUE_NUMBER();
        // 'Upload Objects' tab
        ArrayList outerList = new ArrayList();
        HashMap innerHashMap = null;
        if(migDetails != null && lengthOfMigDetailsBeanArr > 0)
        {
            for(int objectBeanIndex = 0; objectBeanIndex < lengthOfMigDetailsBeanArr; objectBeanIndex ++ )
            {
                beanObj = migDetails[objectBeanIndex];
                //IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                if(beanObj != null)
                {
                	solutionObjectIdList.add(beanObj.getMIG_DEV_ISSUE_SOLUTION_OBJECT_ID());
                }
                System.out.println("Tri2ModelValidator.startValidationProcess()...... migDetails[ " + objectBeanIndex + " ]");
                isObjectAvailable = true;
                
                if(!isSolutionObjectAttached)
                {
                    isSolutionObjectAttached = true;    
                }
                if(beanObj.getMIG_MIGRATION_FLAG() != null && (beanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }
                if(beanObj != null && (beanObj.getOBJECT_MODIFIED() != null && beanObj.getOBJECT_MODIFIED().equalsIgnoreCase("Y")) && beanObj.getMIG_DEV_OBJECT_NAME() != null)
                {
                    String onlinePatchingMode = null;
                    if(beanObj.getONLINE_PATCH_MODE() != null && beanObj.getONLINE_PATCH_MODE().booleanValue())
                    {
                        onlinePatchingMode = "true";  
                    }
                    else
                    {
                        onlinePatchingMode = "false"; 
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...onlinePatchingMode:" + onlinePatchingMode);
                    String editioned = null;
                    if(beanObj.getEDITIONED() != null)
                    {
                        editioned = beanObj.getEDITIONED();
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Upload objects editioned:" + editioned);
                    if(!(editioned != null && !editioned.trim().equalsIgnoreCase("")
                            && editioned.equalsIgnoreCase("Yes")))
                    {
                        editioned = "No";
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Upload objects modified editioned:" + editioned);
                    if((beanObj.getOBJECT_MODIFIED() != null && beanObj.getOBJECT_MODIFIED().equalsIgnoreCase("Y")) && (beanObj.getMIG_DEV_OBJECT_NAME() != null
                            || beanObj.getMIG_DEV_OBJECT_TYPE() != null))
                    /*if(beanObj.getMIG_DEV_OBJECT_NAME() != null
                            || beanObj.getMIG_DEV_OBJECT_TYPE() != null)*/
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;    
                        }
                      //IS109796 - During object mapping, only modified objects should get saved (Right now all objects are getting saved)
                        isAtleastOneObjectModified = true;
                        if(beanObj.getMIG_DEV_OBJECT_NAME() != null
                                && beanObj.getMIG_DEV_OBJECT_TYPE() != null)
                        {
                            String fileName = beanObj.getMIG_DEV_OBJECT_NAME();
                            String objectType = beanObj.getMIG_DEV_OBJECT_TYPE();
                            System.out.println("Tri2ModelValidator.startValidationProcess()...Upload Objects...fileName:" + fileName);
                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectType(Upload Objects):" + objectType);
                            if(objectType != null)
                            {
                                System.out.println("Tri2ModelValidator.startValidationProcess()...Validating File Extn.");
                                this.validateFileExtension(beanObj);
                                System.out.println("Tri2ModelValidator.startValidationProcess()... File Extn Validated Flag: " + returnFlag);
                                String objectName = beanObj.getMIG_DEV_OBJECT_NAME();
                                boolean isSQLObject = false;
                                if(isSchemaRequired(objectType))
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()...isSchemaRequired.beanObj.getMIG_OBJ_DOWNLOAD_SOURCE():"
                                            + beanObj.getMIG_OBJ_DOWNLOAD_SOURCE() + ", beanObj.getMIG_DEV_OBJECT_NAME():" + beanObj.getMIG_DEV_OBJECT_NAME()
                                            + ", beanObj.getMIG_DEV_OBJECT():" + beanObj.getMIG_DEV_OBJECT() + ", beanObj.getMIG_OBJ_DOWNLOAD_SOURCE():" + beanObj.getMIG_OBJ_DOWNLOAD_SOURCE());

                                    if(beanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' is mandatory for "+ objectType +" object.\n      Select 'Schema' for '");
                                        msg.append(objectName);
                                        msg.append("'.\n");

                                        returnFlag = false;
                                    }
                                    isSQLObject = isSQLObjectType(objectType);  // IS110822 - created to add to objects map to check the SQL Line width validation as thread based
                                    if(isSQLObject && beanObj.getDATABASE_TYPE() == null && validateDatabaseType)
                                    {
                                    	msg.append("\n ");
                                    	msg.append(objectName);
                                    	msg.append("\n ");
                                    	msg.append("      [ERROR]: 'Database Type' is mandatory as workflow contains target instances with different database types.\n      Select 'Database Type' for '");
                                    	msg.append(objectName);
                                    	msg.append("'.\n");
                                    	returnFlag = false;
                                    	System.out.println("Tri2ModelValidator.startValidationProcess()..... Database Type in Upload Object Tab ::: " + msg + "return flag " +  returnFlag );
                                    }
                                }

                                if(validateExtractFile.equals("true"))
                                {
                                    System.out.println("SQL file each line length validation flag is true.");
                                    
                                    String attachmentEmailsDirectory = applicationPropsURL.getString("attachmentEmailsDirectory");
                                    String objectNameFolder = beanObj.getMIG_DEV_OBJECT();

                                    HashMap objectDataMap = new HashMap();
                                    objectDataMap.put("attachedFrom", "uploadObj");
                                    objectDataMap.put("objectName", objectName);
                                    objectDataMap.put("attachmentEmailsDirectory", attachmentEmailsDirectory);
                                    objectDataMap.put("objectNameFolder", objectNameFolder);
                                    objectDataMap.put("objectType", objectType);
                                    objectDataMap.put("isSQLObject", isSQLObject); // IS110822 - Added to make the SQL Line width validation as thread based
                                    objectDataMap.put("issueNumber", issueNumber);
                                    /**
                                     * IS079554 - Need to parse all the objects to check whether it is editioned or non-editioned and migrate 
                                     *            all objects to patch edition if any of the object is editioned object in a migration
                                     */
                                    objectDataMap.put("onlinePatchingMode", onlinePatchingMode);
                                    objectDataMap.put("beanIndex", Integer.toString(objectBeanIndex));
                                    //IS105852 -  To include all the AOL Objects to allSQLObjectsDataMap for keyword validation in Upload objects tab
                                    if(isAOLObject(objectType))
                                    {
                                    	System.out.println(objectName + " is adding for AOL Objects ");
                                    	allSQLObjectsDataMap.put("uploadObj_" + Integer.toString(objectBeanIndex), objectDataMap);
                                    }
                                    
                                    if(isValidationRequired(objectType))
                                    {
                                        /*
                                         *IS073963 If we upload corrupted zip using JAR as object type in Upload Objects, even if it is showing as Exception Invalid zip while saving attached objects, still it's proceeding to save into database 
                                         */

                                        if(beanObj.getMIG_DEV_ISSUE_SOLUTION_OBJECT_ID() == null)
                                        {
                                            allSQLObjectsDataMap.put("uploadObj_" + Integer.toString(objectBeanIndex), objectDataMap);
                                        }
                                    }
                                    /**
                                     * IS080795 Validation of Oracle objects in TRI2 Migration Tool based on editioned/non-editioned 
                                     * if Target instance is configured for Online Patching migrations
                                     */
                                    else if(isOnlinePatchingEnabledForTargetInstanceFlag)
                                    {
                                        System.out.println("Tri2ModelValidator.startValidationProcess()...other than SQL in Upload objects!");
                                        objectDataMap.put("editioned", editioned);
                                        allOtherObjectsExceptSQL.put("uploadObj_" + Integer.toString(objectBeanIndex), objectDataMap);
                                    }
                                }
                                
                                /**
                                 * Added by ksdas
                                 * IS078467 - Provide a way to execute Upgrade Pack through Migration Tool
                                 * IS091765 - Automate Idempiere pack in process through migration tool (AOM)
                                 */
                                if(objectType.equalsIgnoreCase("JAR") 
                                		|| objectType.equalsIgnoreCase("UPGRADE_PACK")
                                		|| isIdempierePackInObject(objectType))
                                {
                                    //String objectName = beanObj.getMIG_DEV_OBJECT_NAME();
                                    if( ! objectName.endsWith(".zip"))
                                    {
                                        msg.append("\n ");
                                        msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n");
                                        msg.append("      [ERROR]: OBJECT TYPE '"+ objectType +"' SUPPPORTS ONLY '.zip' FILE.\n ");
                                        returnFlag = false;
                                    }
                                }

                                System.out.println("Tri2ModelValidator.startValidationProcess()...objectType:" + objectType);
                                if("OAF_CUSTOM_OAF_PAGE_OR_REGION".equalsIgnoreCase(objectType)
                                        || "OAF_STANDARD_CONTROLLER_CLASS_FILES".equalsIgnoreCase(objectType)
                                        || "OAF_STANDARD_VO_OR_AM_CLASS_FILES".equalsIgnoreCase(objectType)
                                        || "OAF_STANDARD_EO_CLASS_FILES".equalsIgnoreCase(objectType)
                                        || "OAF_STANDARD_OAF_PERSONALIZATIONS".equalsIgnoreCase(objectType))
                                {
                                    innerHashMap = new HashMap();
                                    innerHashMap.put(objectType, beanObj.getMIG_DEV_OBJECT());
                                    outerList.add(innerHashMap);

                                    if( ! "OAF_STANDARD_CONTROLLER_CLASS_FILES".equalsIgnoreCase(objectType))
                                    {
                                        if(beanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                        {
                                            msg.append("\n ");
                                            msg.append("      [ERROR]: 'Schema' is mandatory for '");
                                            msg.append(objectType);
                                            msg.append("'.\n");
                                            returnFlag = false;
                                        }
                                    }
                                    innerHashMap = null;
                                }
                                /**
                                 * IS068210:Migration of Integration repository
                                 * objects through AOM
                                 */
                                if(objectType.equalsIgnoreCase("INTEGRATION_REPOSITORY_OBJECT"))
                                {
                                    //String objectName = beanObj.getMIG_DEV_OBJECT_NAME();
                                    if( ! objectName.endsWith(".ildt"))
                                    {
                                        msg.append("\n ");
                                        msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n");
                                        msg.append("      [ERROR]: OBJECT TYPE 'INTEGRATION_REPOSITORY_OBJECT' SUPPPORTS ONLY '.ildt' FILE.\n ");
                                        returnFlag = false;
                                    }
                                }

                                if(isObjectTypeAvailable(objectType))
                                {
                                    if((beanObj.getMIG_APPL_SHORT_NAME() == null || beanObj.getMIG_FORM_APPLICATION_TOP() == null)
                                            && this.isApplicationTopRequired(objectType))
                                    {
                                        msg.append("\n ");
                                        msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n");
                                        msg.append("      [ERROR]: 'Oracle Application Top' AND 'Oracle Application Short Name' ARE MANDATORY FOR AOL OBJECTS.\n      Select 'APPLICATION TOP' AND 'APPLICATION SHORT NAME' for '");
                                        msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("'.\n");
                                        returnFlag = false;
                                    }
                                    /**
                                     * IS063446-AOM to support xml pub reports
                                     * migration. as Lob Code is mandatory for
                                     * Publisher Report, we are stopping if it
                                     * is not given
                                     */
                                    /*
                                     *  IS086656 - i. Need LOV for Language for XML PUB reports migration. 
                                     *  ii. Make LOB_TYPE and XDO_FILE_TYPE as mandatory for XML_PUB_REPORTS migration.
                                     */
                                    if(objectType.equalsIgnoreCase("XML_PUB_REPORTS"))
                                    {
                                    	if(!(beanObj.getLOB_CODE() != null && ! beanObj.getLOB_CODE().equalsIgnoreCase("")) 
                                    			|| !(beanObj.getLOB_TYPE() != null && ! beanObj.getLOB_TYPE().equalsIgnoreCase(""))
                                    			|| !(beanObj.getXDO_FILE_TYPE() != null && ! beanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                    	{
                                    		msg.append("\n ");
                                    		msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("\n");
                                    	}
                                    	if(!(beanObj.getLOB_CODE() != null && ! beanObj.getLOB_CODE().equalsIgnoreCase("")))
                                    	{
                                    		msg.append("      [ERROR]: 'LOB Code' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Code' for '");
                                    		msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("'.\n");
                                    		returnFlag = false;
                                    	}
                                    	if(!(beanObj.getLOB_TYPE() != null && ! beanObj.getLOB_TYPE().equalsIgnoreCase("")))
                                    	{ 
                                    		msg.append("\n      [ERROR]: 'LOB Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Type' for '");
                                    		msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("'.\n");
                                    		returnFlag = false;
                                    	}
                                    	if(!(beanObj.getXDO_FILE_TYPE() != null && ! beanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                    	{ 
                                    		msg.append("\n      [ERROR]: 'XDO File Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'XDO File Type' for '");
                                    		msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("'.\n");
                                    		returnFlag = false;
                                    	}
                                    }

                                    if(beanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        beanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                    }
                                }

                                /**
                                 * Commented by Kallu on 03/04/2013. For
                                 * removing Validation for ORACLE_PATCH
                                 */

                                /*
                                 * if(objectType.equalsIgnoreCase("ORACLE_PATCH")
                                 * ) { if(beanObj.getORACLE_PATCH_NUMBER() ==
                                 * null) { msg.append("\n " +
                                 * beanObj.getMIG_DEV_OBJECT_NAME() + "\n");
                                 * msg.append (
                                 * "      [ERROR]: PLEASE PROVIDE ORACLE PATCH NUMBER."
                                 * ); returnFlag = false; } }
                                 */
                                /**@author teja.miryala
                                 * IS079907 - AOM to support for ADF migrations/any EAR file migrations.
                                 */
                                if(objectType.equalsIgnoreCase("EAR_FILE"))
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                            + objectName + ", objectType:" + objectType);
                                    if(objectName != null)
                                    {
                                        if(! objectName.toLowerCase().endsWith(".ear") )
                                        {
                                            System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.ear) :: ");
                                            msg.append("\n ");
                                            msg.append(objectName);
                                            msg.append("\n");
                                            msg.append("      [ERROR]: OBJECT TYPE 'EAR_FILE' SUPPORTS ONLY '.ear' FILE.\n ");
                                            returnFlag = false;
                                        }
                                    }
                                }
                                /*
                                 * IS091762 - Idempiere custom code (bundles) migration through AOM
                                 */
                                if(objectType.equalsIgnoreCase("IDEMPIERE_BUNDLE"))
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                            + objectName + ", objectType:" + objectType);
                                    if(objectName != null)
                                    {
                                        if(! objectName.toLowerCase().endsWith(".jar") )
                                        {
                                            System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                                            msg.append("\n ");
                                            msg.append(objectName);
                                            msg.append("\n");
                                            msg.append("      [ERROR]: OBJECT TYPE 'IDEMPIERE_BUNDLE' SUPPORTS ONLY '.jar' FILE.\n ");
                                            returnFlag = false;
                                        }
                                    }
                                }
                                
                                //IS097480 - Provision to migrate oracle form libraries (custom.pll) through AOM
                                if("ORACLE_FORM_LIBRARIES".equalsIgnoreCase(objectType))
                                {
                                	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                			+ objectName + ", objectType:" + objectType);
                                	if(beanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        beanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                    }
                                	if(beanObj.getMIG_APPL_SHORT_NAME() == null)
                               	 	{
                                		beanObj.setMIG_APPL_SHORT_NAME("AU");
                               	 	}
                                	if(beanObj.getMIG_FORM_APPLICATION_TOP() == null)
                                	{
                                		beanObj.setMIG_FORM_APPLICATION_TOP("AU_TOP");
                                	}
                                }
                                
                                if(objectType.equalsIgnoreCase("BA_FOLDER")
                                        || objectType.equalsIgnoreCase("BUSINESS_AREA")
                                        || objectType.equalsIgnoreCase("WORKBOOK"))
                                {
                                    if(beanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' IS MANDATORY FOR DISCOVERER OBJECTS.\n      Select 'Schema' for '");
                                        msg.append(objectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA UploadObjects ::: "
                                                + msg + ", FLAG :" + returnFlag);
                                    }
                                    if(beanObj.getORA_DISC_EUL_NAME() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'EUL Name' IS MANDATORY FOR OBJECTS.\n      Select 'EUL Name' for '");
                                        msg.append(objectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                    }
                                }

                                if(objectType.equalsIgnoreCase("COPY")
                                        || objectType.equalsIgnoreCase("COPY AND EXTRACT")
                                        || objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                        || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                        || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")
                                        /**
                    					 * IS109799 - Provision for softlink migration through AOM
                    					 */
                                        || objectType.equalsIgnoreCase("SOFTLINK")
                                	
                                      //IS111135 - Migration of OAF Objects getting failed when mapped from CVS/SVN/GIT tabs
                                        
                                        || objectType.equalsIgnoreCase("OAF-COPY")
                                        || objectType.equalsIgnoreCase("OAF-WEB_UI")
                                        || objectType.equalsIgnoreCase("OAF_STANDARD-JPX")
                                        || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-COPY")
                                        || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-WEB_UI"))

                                   {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()objectType inside COPY :: "
                                            + objectType);
                                    //String objectName = beanObj.getMIG_DEV_OBJECT_NAME();
                                    System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                            + objectName + ", objectType:" + objectType);
                                    if(objectType.equalsIgnoreCase("COPY AND EXTRACT"))
                                    {
                                        if(objectName != null)
                                        {
                                            if( ! objectName.endsWith(".zip"))
                                            {
                                                System.out.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.zip) :: ");
                                                msg.append("\n ");
                                                msg.append(objectName);
                                                msg.append("\n");
                                                // msg.append("\n " +
                                                // beanObj.getMIG_DEV_OBJECT_NAME()
                                                // + "\n");
                                                msg.append("      [ERROR]: OBJECT TYPE 'COPY AND EXTRACT' SUPPPORTS ONLY '.zip' FILE.\n ");
                                                returnFlag = false;
                                            }
                                        }
                                    }
                                    if(beanObj.getTEMP_BASE_PATH() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n");
                                        // msg.append("\n " +
                                        // beanObj.getMIG_DEV_OBJECT_NAME() +
                                        // "\n");
                                        msg.append("      [ERROR]: Target directory folder is mandatory for object type '"
                                                + objectType);

                                        if((objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                                || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                                || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")))
                                        {

                                            if(objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS"))
                                            {
                                                msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'USER.DEFINED.BP' \n");
                                            }
                                            else if(objectType.equalsIgnoreCase("INFOLEASE_REPORTS"))
                                            {
                                                msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'RECALLS' \n");
                                            }
                                            else if(objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS"))
                                            {
                                                msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'njs' \n");
                                            }
                                        }
                                        else
                                        {
                                            msg.append("'.\n      Provide valid path in 'Target Path' field. \n      For exapmle :: '$XX_TOP/bin/..etc.' \n\n");
                                        }
                                        returnFlag = false;
                                    }
                                    else
                                    {
                                        beanObj.setMIG_FORM_APPLICATION_TOP(beanObj.getTEMP_BASE_PATH());
                                    }
                                }
                                /*
                                 *  IS086656 - i. Need LOV for Language for XML PUB reports migration. 
                                 *  ii. Make LOB_TYPE and XDO_FILE_TYPE as mandatory for XML_PUB_REPORTS migration.
                                 *  Logic to clear language which is set by default to 'en' even if object type is
                                 *  other than XML_PUB_REPORTS
                                 */
                                if((!objectType.equalsIgnoreCase("XML_PUB_REPORTS")) && beanObj.getLANGUAGE() != null)
                                {
                                	beanObj.setLANGUAGE(null);
                                }
                                else if(beanObj.getLANGUAGE() == null)
                                {
                                	beanObj.setLANGUAGE("en");
                                }
                                /**
                                 * IS112542 - While migration of Execute shell script object type, right now the target path is not being captured in migration log though provided.
                                 * */
                                if(objectType.equalsIgnoreCase("EXECUTE_SHELL SCRIPT") && beanObj.getTEMP_BASE_PATH() != null)
                                {
                                	beanObj.setMIG_FORM_APPLICATION_TOP(beanObj.getTEMP_BASE_PATH());
                                }
                            }

                            System.out.println("Tri2ModelValidator.startValidationProcess()...beanObj.getMIG_DEV_OBJECT()::"
                                    + beanObj.getMIG_DEV_OBJECT() + ", beanObj.getMIG_DEV_OBJECT_NAME():" + beanObj.getMIG_DEV_OBJECT_NAME());
                        }
                        else
                        {
                            msg.append("      [ERROR]: Please provide all required fields for ");
                            if(beanObj.getMIG_DEV_OBJECT_NAME() != null && !beanObj.getMIG_DEV_OBJECT_NAME().equalsIgnoreCase(""))
                            {
                                msg.append("'");
                                msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                                msg.append("'");
                            }
                            else
                            {
                                msg.append("Upload objects");
                            }
                            msg.append(".\n\n");
                            returnFlag = false;
                        }
                        /*
                         * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                         */
                        if(beanObj.getMIG_MIGRATION_FLAG() != null && (beanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                        {
                            if(!atleastOneMigrateFlagChecked)
                            {
                                atleastOneMigrateFlagChecked = true;
                            }
                        }
                    }
                    /*else
                    {
                        if(beanObj.getMIG_DEV_OBJECT_NAME() != null)
                        {
                            msg.append("\n ");
                            msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                        }
                        msg.append("\n");
                        msg.append("      [ERROR]: OBJECT TYPE is mandatory for the object in Upload objects.\n");
                        returnFlag = false;
                    }*/
                    /**
                     * IS090169 - Provide depend on feature for migrations in AOM
                     */
					
//					  migrationSequence = beanObj.getMIG_MIGRATION_SEQUENCE();
//					  migrationSequences.add(migrationSequence);
//					  
//					  dependOn = beanObj.getDEPEND_ON(); 
//				      dependOns.add(dependOn); 
//					  System.out.println("Tri2ModelValidator.startValidationProcess()(Upload Objects)...migrationSequence:"
//					  + migrationSequence + ", dependOn:" + dependOn);
                }
	                migrationSequence = beanObj.getMIG_MIGRATION_SEQUENCE();
	                migrationSequences.add(migrationSequence);
	                dependOn = beanObj.getDEPEND_ON(); 
				    dependOns.add(dependOn);
				    
				    /**
			         * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
			         */
				    
				    onSuccess = beanObj.getON_SUCCESS();
				    onSuccesses.add(onSuccess);
				    successMap.put(migrationSequence, onSuccess);
				    onFailure = beanObj.getON_FAILURE();
				    onFailures.add(onFailure);
				    failureMap.put(migrationSequence, onFailure);
				    System.out.println("Tri2ModelValidator.startValidationProcess()(Upload Objects)...onSuccess:" + onSuccess
	                        + ", onFailure:" + onFailure);
            }
            if(returnFlag)
            {
                if(outerList != null && outerList.size() > 0)
                {
                    processOAFZipsForValidation(outerList);
                }
            }
        }

        /**
         * *********************************************************************
         * ************************************************
         * :::::::::::::::::::::::::::::: End of SG_TRI2_MIGRATION_DETAILS
         * object iteration ::::::::::::::::::::::::::::::::
         * ********************
         * **************************************************
         * ***********************************************
         */

        // 'Map CVS Objects' tab
        if(cvsMappedMigDetails != null && lengthOfCvsMappedObjBeanArr > 0)
        {
        	 Boolean autoFillTopAndShortNameflag = false;
            for(int cvsObjectsIndex = 0; cvsObjectsIndex < lengthOfCvsMappedObjBeanArr; cvsObjectsIndex ++ )
            {
                cvsMappedBeanObj = cvsMappedMigDetails[cvsObjectsIndex];
                System.out.println("Tri2ModelValidator.startValidationProcess()..cvsMappedBeanObj :- " +cvsMappedBeanObj);
                //IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                if(cvsMappedBeanObj != null)
                {
                	solutionObjectIdList.add(cvsMappedBeanObj.getMIG_DEV_ISSUE_SOLUTION_OBJECT_ID());
                }
                isObjectAvailable = true;
                
                if(!isSolutionObjectAttached)
                {
                    isSolutionObjectAttached = true;
                }
                if(cvsMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (cvsMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }

                if(cvsMappedBeanObj != null && (cvsMappedBeanObj.getOBJECT_MODIFIED() != null && cvsMappedBeanObj.getOBJECT_MODIFIED().equalsIgnoreCase("Y")) && cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                {
                    String onlinePatchingMode = null;
                    if(cvsMappedBeanObj.getONLINE_PATCH_MODE() != null && cvsMappedBeanObj.getONLINE_PATCH_MODE().booleanValue())
                    {
                        onlinePatchingMode = "true";  
                    }
                    else
                    {
                        onlinePatchingMode = "false"; 
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()....cvsMappedMigDetails [ " + cvsObjectsIndex + " ] :" + cvsMappedBeanObj);

                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map CVS onlinePatchingMode:" + onlinePatchingMode);
                    String editioned = null;
                    if(cvsMappedBeanObj.getEDITIONED() != null)
                    {
                        editioned = cvsMappedBeanObj.getEDITIONED();
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map CVS editioned:" + editioned);
                    if(!(editioned != null && !editioned.trim().equalsIgnoreCase("")
                            && editioned.equalsIgnoreCase("Yes")))
                    {
                        editioned = "No";
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map CVS modified editioned:" + editioned);

                    String cvsObjectExpectedPath = cvsMappedBeanObj.getMIG_DEV_OBJECT_EXPECTED_PATH();
                    System.out.println("Tri2ModelValidator.startValidationProcess()...cvsObjectExpectedPath:" + cvsObjectExpectedPath);
                    String cvsObjectExpectedExtension = cvsMappedBeanObj.getMIG_DEV_FILE_EXTENSION();
                    System.out.println("Tri2ModelValidator.startValidationProcess()...cvsObjectExpectedExtension:" + cvsObjectExpectedExtension);
                    Boolean errorFlag = true;

                    if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null 
                            && cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                    {
                        if(cvsObjectExpectedPath != null
                                && ! cvsObjectExpectedPath.equalsIgnoreCase(""))
                        {
                            String[] cvsMultiObjectExpectedPath = cvsObjectExpectedPath.split(",");
                            String fileName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                            System.out.println("Tri2ModelValidator.startValidationProcess()...Map CVS...fileName:" + fileName);
                            String objectType = cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            int lastIndexOfSlash = fileName.lastIndexOf("/");
                            String objectFolderPath = fileName.substring(0, lastIndexOfSlash);
                            String configuredPath = null;

                            for(int expectedPathIndex = 0; expectedPathIndex < cvsMultiObjectExpectedPath.length; expectedPathIndex ++ )
                            {
                                configuredPath = cvsMultiObjectExpectedPath[expectedPathIndex];
                                if (configuredPath != null && configuredPath.endsWith("/"))
                                {
                                    configuredPath = configuredPath.substring(0, configuredPath.length() - 1);
                                }
                                if(objectFolderPath.equals(configuredPath))
                                {
                                    errorFlag = false;
                                    break;
                                }
                            }

                            if(errorFlag)
                            {
                                msg.append("\n ");
                                msg.append(objectType);
                                msg.append(" :- ");
                                msg.append(fileName);
                                msg.append(".\n ");
                                msg.append("[ERROR]:  Above attached object is not mapped from the expected path.\nPlease commit this object in correct path of Repository and map again. ");
                                msg.append("\n ");
                                msg.append("Expected path :- '");
                                msg.append(cvsObjectExpectedPath);
                                msg.append("'.\n");

                                returnFlag = false;
                                System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Cvs ::: "
                                        + msg + "   FLAG : " + returnFlag);
                            }

                        }
                        errorFlag = true;
                        if(cvsObjectExpectedExtension != null
                                && ! cvsObjectExpectedExtension.equalsIgnoreCase(""))
                        {
                            String[] cvsMultiObjectExpectedExtension = cvsObjectExpectedExtension.split(",");
                            String fileName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                            String objectType = cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            int objIndex = fileName.lastIndexOf('.');
                            int length = fileName.length();
                            String  expectedExtension = fileName.substring(objIndex+1,length);
                            System.out.println(expectedExtension);
                            for(int i = 0; i < cvsMultiObjectExpectedExtension.length; i ++ )
                            {
                                if(expectedExtension.equalsIgnoreCase(cvsMultiObjectExpectedExtension[i]))
                                {
                                    errorFlag = false;
                                    break;
                                }
                            }

                            if(errorFlag)
                            {
                                msg.append("\n '");
                                msg.append(objectType);
                                msg.append("' :- ");
                                msg.append(fileName);
                                msg.append("\n ");
                                msg.append("[ERROR]:Please provide correct extension for above object. ");
                                msg.append("\n ");
                                msg.append("Expected Extension :- '");
                                msg.append(cvsObjectExpectedExtension);
                                msg.append("'.\n");

                                returnFlag = false;
                                System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Cvs ::: "
                                        + msg + "   FLAG : " + returnFlag);
                            }
                        }

                    }

                    if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null
                            || cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;
                        }
                        isAtleastOneObjectModified = true;
                        String cvsObjectName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                        String cvsOldObjectName = cvsMappedBeanObj.getMIG_DEV_OLD_OBJECT_NAME();
                        System.out.println("Tri2ModelValidator.startValidationProcess()...cvsObjectName:" + cvsObjectName);
                        if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null
                                && cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                        {
                            /**
                             * IS066428 Provide an easy way to re-map an object
                             * with its latest version in Attach Solution
                             * Objects page
                             */
                            Boolean latestVersionFlagChecked = cvsMappedBeanObj.getLATEST_VERSION_FLAG();
                            if(latestVersionFlagChecked != null
                                    && latestVersionFlagChecked.booleanValue()
                                    && cvsObjectName.equals(cvsOldObjectName))
                            {
                                String latestVersion = cvsMappedBeanObj.getMIG_DEV_OBJECT_LATEST_VERSION();
                                if(latestVersion != null)
                                {
                                    cvsMappedBeanObj.setMIG_DEV_OBJECT_VERSION(latestVersion);
                                }
                            }
                            System.out.println("Tri2ModelValidator.startValidationProcess()...Validating File Extn.");
                            this.validateFileExtension(cvsMappedBeanObj);
                            System.out.println("Tri2ModelValidator.startValidationProcess()...File Extn. Validated  flag: "
                                    + returnFlag);

                            String objectType = cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectType(MapCVS):" + objectType);
                            String copyBasePath = cvsMappedBeanObj.getTEMP_BASE_PATH();
                            String objectVersionString = cvsMappedBeanObj.getMIG_DEV_OBJECT_VERSION();

                            String objectDownloadSource = cvsMappedBeanObj.getMIG_OBJ_DOWNLOAD_SOURCE();
                            /**
                             * IS081768 - Provide an option to re-execute database compliance checker 
                             * and re-validate the migration objects on demand(while approving ticket to proceed for migration)
                             */
                            String cvsProjectModule = null;
                            int lastSlash = cvsObjectName.lastIndexOf("/");
                            String objectPath = null;
                            if(lastSlash != - 1)
                            {
                                objectPath = cvsObjectName.substring(0, lastSlash);
                                cvsProjectModule = objectPath;
                                cvsObjectName = cvsObjectName.substring(lastSlash + 1, cvsObjectName.length());
                            }

                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectType: "
                                    + objectType + ", copyBasePath :" + copyBasePath + ", cvsObjectName:"
                                    + cvsObjectName + ", objectVersionString :" + objectVersionString 
                                    + ", objectDownloadSource : "+ objectDownloadSource +", cvsProjectModule: " + cvsProjectModule);

                            double objectVersionDoubleValue = 0;

                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectType:" + objectType);
                            if(objectType != null)
                            {
                            	boolean isSQLObject = false;
                                if(isSchemaRequired(objectType))
                                {
                                    if(cvsMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' is mandatory for "+ objectType +" object.\n      Select 'Schema' for '");
                                        msg.append(cvsObjectName);
                                        msg.append("'.\n");

                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Cvs ::: "
                                                + msg
                                                + "   FLAG : "
                                                + returnFlag);
                                    }
                                    isSQLObject = isSQLObjectType(objectType);// IS110822 - Added to make the SQL Line width validation as thread based
                                    if(isSQLObject && cvsMappedBeanObj.getDATABASE_TYPE() == null && validateDatabaseType)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Database Type' is mandatory as workflow contains target instances with different database types.\n      Select 'Database Type' for '");
                                        msg.append(cvsObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... Database Type in Cvs ::: " + msg + "return Flag " + returnFlag);
                                    }
                                }
                                System.out.println(" Inside CVS SQL file each line length validation falg is validateExtractFile::" + validateExtractFile);
                                HashMap beanDataObject = new HashMap();
                                if(validateExtractFile.equals("true"))
                                {
                                    System.out.println(" Inside CVS SQL file each line length validation falg is true.");

                                   
                                    beanDataObject.put("cvsMappedBeanObj", cvsMappedBeanObj);
                                    beanDataObject.put("attachedFrom", "mapCVS");
                                    beanDataObject.put("cvsObjectName", cvsObjectName);
                                    beanDataObject.put("cvsObjectVersion", objectVersionString);
                                    beanDataObject.put("cvsProjectModule", cvsProjectModule);
                                    beanDataObject.put("cvsType", objectDownloadSource);
                                    beanDataObject.put("objectType", objectType);
                                    beanDataObject.put("isSQLObject", isSQLObject); // IS110822 - Added to make the SQL Line width validation as thread based
                                    beanDataObject.put("issueNumber", issueNumber);
                                    /**
                                     * IS079554 - Need to parse all the objects to check whether it is editioned or non-editioned and migrate 
                                     *            all objects to patch edition if any of the object is editioned object in a migration
                                     */
                                    beanDataObject.put("onlinePatchingMode", onlinePatchingMode);
                                    beanDataObject.put("beanIndex", Integer.toString(cvsObjectsIndex));
                                    System.out.println("Tri2ModelValidator.startValidationProcess() beanDataObject::" + beanDataObject);
                                    if(isAOLObject(objectType))
                                    {
                                    	System.out.println(cvsObjectName + " is adding for AOL Objects ");
                                    	allSQLObjectsDataMap.put("mapCVS_" + Integer.toString(cvsObjectsIndex), beanDataObject);
                                    }
                                    else if(isValidationRequired(objectType))
                                    {
                                        System.out.println(cvsObjectName
                                                + " is adding for SQL file each line length validation. ");
                                        allSQLObjectsDataMap.put("mapCVS_" + Integer.toString(cvsObjectsIndex), beanDataObject);
                                    }
                                    /**
                                     * IS080795 Validation of Oracle objects in TRI2 Migration Tool based on editioned/non-editioned 
                                     * if Target instance is configured for Online Patching migrations
                                     */
                                    else if(isOnlinePatchingEnabledForTargetInstanceFlag)
                                    {
                                        System.out.println("Tri2ModelValidator.startValidationProcess()...other than SQL in Map CVS!");
                                        beanDataObject.put("editioned", editioned);
                                        allOtherObjectsExceptSQL.put("mapCVS_" + Integer.toString(cvsObjectsIndex), beanDataObject);
                                    }
                                }
                                else
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()...validateExtractFile:" + validateExtractFile);
                                }
                                /*if(objectType.equalsIgnoreCase("JAR"))
                                {
                                    String objectName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                    if( ! objectName.endsWith(".zip"))
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        // msg.append("\n " +
                                        // cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME()
                                        // + "\n");
                                        msg.append("      [ERROR]: OBJECT TYPE 'JAR' SUPPPORTS ONLY '.zip' FILE.\n ");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Cvs ::: "
                                                + msg
                                                + "   FLAG : "
                                                + returnFlag);
                                    }
                                }*/

                                /**
                                 * IS068210:Migration of Integration repository
                                 * objects through AOM
                                 */
                                /*if(objectType.equalsIgnoreCase("INTEGRATION_REPOSITORY_OBJECT"))
                                {
                                    String objectName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                    if( ! objectName.endsWith(".ildt"))
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        // msg.append("\n " +
                                        // cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME()
                                        // + "\n");
                                        msg.append("      [ERROR]: OBJECT TYPE 'INTEGRATION_REPOSITORY_OBJECT' SUPPPORTS ONLY '.ildt' FILE.\n ");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Cvs ::: "
                                                + msg
                                                + "   FLAG : "
                                                + returnFlag);
                                    }
                                }
                                 */
                                if(objectType.equalsIgnoreCase("BA_FOLDER")
                                        || objectType.equalsIgnoreCase("BUSINESS_AREA")
                                        || objectType.equalsIgnoreCase("WORKBOOK"))
                                {
                                    String cvsObjSchema = cvsMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA();
                                    if(cvsObjSchema == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsObjSchema);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' IS MANDATORY FOR DISCOVERER OBJECTS.\n      Select 'Schema' for '");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA MapCvs ::: "
                                                + msg + ", FLAG : " + returnFlag);
                                    }
                                    if(cvsMappedBeanObj.getORA_DISC_EUL_NAME() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'EUL Name' IS MANDATORY FOR OBJECTS.\n      Select 'EUL Name' for '");
                                        msg.append(cvsObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                    }
                                }

                                if(isObjectTypeAvailable(objectType))
                                {
                                    if(cvsMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        cvsMappedBeanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                    }
                                    
                                    String fetchShortNameAndTopNameFromLDTFile = null;
                                    boolean flag = false;
                                    ResourceBundle resourceBundle = ResourceBundle.getBundle("ContextPath");
                                    String tri2URL = resourceBundle.getString("tri2MigrationServleturl");
                                	String propKey = "ShortNameNTopNameFetchFromFileOrNot";
                                	String patternName = null;
                                    if(resourceBundle != null)
                                    {
                                    	
                                    	fetchShortNameAndTopNameFromLDTFile = (String)getThePropertyValueOrCheckingPatternForAOLObject(tri2URL,propKey,flag);
                                    	System.out.println("Tri2ModelValidator.startValidationProcess() FOR MapCVS..fetchShortNameAndTopNameFromLDTFile : "+fetchShortNameAndTopNameFromLDTFile );
                                    }
                                    
                                    if(fetchShortNameAndTopNameFromLDTFile != null && fetchShortNameAndTopNameFromLDTFile.equalsIgnoreCase("True"))
                                    {
                                    	flag = true;
                                    	
                                    	HashMap commPatternobjTypInDBData = (HashMap)getThePropertyValueOrCheckingPatternForAOLObject(tri2URL,objectType,flag);
                                    	System.out.println("Tri2ModelValidator.startValidationProcess() FOR MapCVS..commPatternobjTypInDBtrueOrFalse : "+commPatternobjTypInDBData);
                                    	
                                    	autoFillTopAndShortNameflag = (Boolean)commPatternobjTypInDBData.get("patternFoundOrNot");
                                    	System.out.println("Tri2ModelValidator.startValidationProcess() FOR MapCVS..autoFillTopAndShortNameflag :- "+autoFillTopAndShortNameflag);
                                    	if(autoFillTopAndShortNameflag.booleanValue())
                                    	{
                                    		patternName = (String) commPatternobjTypInDBData.get("patternForOracleTop");
                                    		System.out.println("Tri2ModelValidator.startValidationProcess() FOR MapCVS..patternName :- "+patternName);
                                    	}
                                    	
                                    
                                    }
                                  
                                    // HashMap beanDataObject = (HashMap) allOtherObjectsExceptSQL.get("mapCVS_" + Integer.toString(cvsObjectsIndex));
                                   
                                    System.out.println("Tri2ModelValidator.startValidationProcess()..MapCVS  before beanDataObject :- "+beanDataObject);
                                     beanDataObject.put("autoFillTopAndShortNameflag", autoFillTopAndShortNameflag);
                                     beanDataObject.put("patternName", patternName);
                                     allOtherObjectsExceptSQL.put("mapCVS_" + Integer.toString(cvsObjectsIndex), beanDataObject);
                                    
                                    System.out.println("Tri2ModelValidator.startValidationProcess()..MapCVS  after beanDataObject :- "+beanDataObject);

                                    
                                    if(!autoFillTopAndShortNameflag.booleanValue())
                                    {
                                    	  if((cvsMappedBeanObj.getMIG_APPL_SHORT_NAME() == null || cvsMappedBeanObj.getMIG_FORM_APPLICATION_TOP() == null)
                                                  && this.isApplicationTopRequired(objectType) )
                                          {
                                              msg.append("\n ");
                                              msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                              msg.append("\n ");
                                              msg.append("      [ERROR]: 'Oracle Application Top' AND 'Oracle Application Short Name' ARE MANDATORY FOR AOL OBJECTS.\n      Select 'Oracle Application Top' AND 'Oracle Application Short Name' for '");
                                              msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                              msg.append("'.\n");
                                              returnFlag = false;
                                              System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Cvs ::: "
                                                      + msg
                                                      + "   FLAG : "
                                                      + returnFlag);
                                          }
                                    }

                                  
                                    /**
                                     * IS063446-AOM to support xml pub reports
                                     * migration.
                                     */
                                    /*
                                     *  IS086656 - i. Need LOV for Language for XML PUB reports migration. 
                                     *  ii. Make LOB_TYPE and XDO_FILE_TYPE as mandatory for XML_PUB_REPORTS migration.
                                     */
                                    if(objectType.equalsIgnoreCase("XML_PUB_REPORTS"))
                                    {
                                    	if(!(cvsMappedBeanObj.getLOB_CODE() != null && ! cvsMappedBeanObj.getLOB_CODE().equalsIgnoreCase(""))
                                    			|| !(cvsMappedBeanObj.getLOB_TYPE() != null && ! cvsMappedBeanObj.getLOB_TYPE().equalsIgnoreCase(""))
                                    			|| !(cvsMappedBeanObj.getXDO_FILE_TYPE() != null && ! cvsMappedBeanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                    	{
                                    		msg.append("\n ");
                                    		msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("\n");
                                    	}
                                    	if(!(cvsMappedBeanObj.getLOB_CODE() != null && ! cvsMappedBeanObj.getLOB_CODE().equalsIgnoreCase("")))
                                    	{
                                    		msg.append("      [ERROR]: 'LOB Code' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Code' for '");
                                    		msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("'.\n");
                                    		returnFlag = false;
                                    	}
                                    	if(!(cvsMappedBeanObj.getLOB_TYPE() != null && ! cvsMappedBeanObj.getLOB_TYPE().equalsIgnoreCase("")))
                                    	{ 
                                    		msg.append("\n      [ERROR]: 'LOB Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Type' for '");
                                    		msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("'.\n");
                                    		returnFlag = false;
                                    	}
                                    	if(!(cvsMappedBeanObj.getXDO_FILE_TYPE() != null && ! cvsMappedBeanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                    	{ 
                                    		msg.append("\n      [ERROR]: 'XDO File Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'XDO File Type' for '");
                                    		msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    		msg.append("'.\n");
                                    		returnFlag = false;
                                    	}
                                    }

                                    if(objectType.equalsIgnoreCase("ORACLE_WORKFLOW")
                                            && cvsMappedBeanObj.getOracleWorkFlowUploadMode() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Oracle WorkFlow Upload Mode' IS MANDATORY FOR ORACLE WORKFLOW MIGRATION,SELECT MODE VALUE FORM LIST OF VALUES OF 'OracleWorkflow Upload Mode'.\n");
                                        returnFlag = false;
                                    }
                                }

                                /**
                                 * @author skolla IS068968 Provide a feature to
                                 *         migrate the Info Lease Objects
                                 *         through TRI2
                                 */
                                if(objectType.equalsIgnoreCase("INFOLEASE_DICTIONARY_OBJECTS"))
                                {
                                    String objectName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                    System.out.println("Tri2ModelValidator.startValidationProcess() INFOLEASE_DICTIONARY_OBJECTS objectName "
                                            + objectName);

                                    if(beanObj.getDESTINATION_DICTIONARY_FILE() == null
                                            || beanObj.getDICTIONARY_RECORD_IDS() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        if(beanObj.getDESTINATION_DICTIONARY_FILE() == null)
                                        {
                                            msg.append("\n");
                                            msg.append("\n");
                                            msg.append("      [ERROR]: Target Dictionary File Name is mandatory for object type 'INFOLEASE_DICTIONARY_OBJECTS'.\n\n     Please provide valid Target file name in 'Target Dictionary File' field. \n \n");
                                        }

                                        if(beanObj.getDICTIONARY_RECORD_IDS() == null)
                                        {
                                            msg.append("\n\n");
                                            msg.append("      [ERROR]: DictionaryRecord Id's is mandatory for object type 'INFOLEASE_DICTIONARY_OBJECTS'.\n\n      Please provide valid Dictionary Record Id's (for multiple record id's provide comma separated values ) in 'Dictionary Record Id's' field. \n\n");
                                        }
                                        returnFlag = false;
                                    }
                                }

                                if(objectType.equalsIgnoreCase("COPY")
                                        || objectType.equalsIgnoreCase("COPY AND EXTRACT")
                                        || objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                        || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                        || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")
                                        || objectType.equalsIgnoreCase("SOFTLINK")
                                	
                                      //IS111135 - Migration of OAF Objects getting failed when mapped from CVS/SVN/GIT tabs
                                        
                                        || objectType.equalsIgnoreCase("OAF-COPY")
                                        || objectType.equalsIgnoreCase("OAF-WEB_UI")
                                        || objectType.equalsIgnoreCase("OAF_STANDARD-JPX")
                                        || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-COPY")
                                        || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-WEB_UI"))
                                {
                                    String objectName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                    /*if(objectType.equalsIgnoreCase("COPY AND EXTRACT"))
                                    {
                                        if(objectName != null)
                                        {
                                            if( ! objectName.endsWith(".zip"))
                                            {
                                                System.out.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.zip) :: ");
                                                msg.append("\n ");
                                                msg.append(objectName);
                                                msg.append("\n");
                                                // msg.append("\n " +
                                                // beanObj.getMIG_DEV_OBJECT_NAME()
                                                // + "\n");
                                                msg.append("      [ERROR]: OBJECT TYPE 'COPY AND EXTRACT' SUPPPORTS ONLY '.zip' FILE.\n ");
                                                returnFlag = false;
                                            }
                                        }
                                    }*/
                                    if(copyBasePath == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n ");
                                        // msg.append("\n " +
                                        // cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME()
                                        // + "\n");
                                        /* msg.append("      [ERROR]: Target directory path is mandatory for object type '"+objectType+ "'.\n      Provide valid path in 'Target Path' field. \n      For Reference :: '$XX_TOP/bin/..etc.' \n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess().... COPY Cvs ::: "
                                                + msg);*/

                                        msg.append("      [ERROR]: Target directory folder is mandatory for object type '"
                                                + objectType);

                                        if((objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                                || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                                || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")))
                                        {

                                            if(objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS"))
                                            {
                                                msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'USER.DEFINED.BP' \n");
                                            }
                                            else if(objectType.equalsIgnoreCase("INFOLEASE_REPORTS"))
                                            {
                                                msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'RECALLS' \n");
                                            }
                                            else if(objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS"))
                                            {
                                                msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For exapmle :: 'njs' \n");
                                            }
                                        }
                                        else
                                        {
                                            msg.append("'.\n      Provide valid path in 'Target Path' field. \n      For Reference :: '$XX_TOP/bin/..etc.' \n\n");
                                        }
                                        returnFlag = false;
                                    }
                                    else
                                    {
                                        cvsMappedBeanObj.setMIG_FORM_APPLICATION_TOP(copyBasePath);
                                    }
                                }

                                if(objectType.equalsIgnoreCase("ORACLE_PATCH"))
                                {
                                    if(cvsMappedBeanObj.getORA_SYSTEM_PWD() == null
                                            || cvsMappedBeanObj.getORACLE_PATCH_NUMBER() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n ");
                                        // msg.append("\n " +
                                        // cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME()
                                        // + "\n");
                                        msg.append("      [ERROR]: PLEASE PROVIDE ORACLE SYSTEM USER PASSWORD AND ORACLE PATCH NUMBER.");
                                        returnFlag = false;
                                    }
                                }
                                /**
                                 * IS092334 - Provision to map idempiere objects from CVS and SVN to migrate.
                                 */
                                if(objectType.equalsIgnoreCase("IDEMPIERE_BUNDLE"))
                                {
                                	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                			+ cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                                	if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                                	{
                                		if(! cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME().toLowerCase().endsWith(".jar") )
                                		{
                                			System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                                			msg.append("\n ");
                                			msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                			msg.append("\n");
                                			msg.append("      [ERROR]: OBJECT TYPE " + objectType + " SUPPORTS ONLY '.jar' FILE.\n ");
                                			returnFlag = false;
                                		}
                                	}
                                }
                                
                                
                                //IS097480 - Provision to migrate oracle form libraries (custom.pll) through AOM
                                if("ORACLE_FORM_LIBRARIES".equalsIgnoreCase(objectType))
                                {
                                	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                			+ cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);

                                	if(cvsMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                		cvsMappedBeanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                    }
                                	if(cvsMappedBeanObj.getMIG_APPL_SHORT_NAME() == null)
                               	 	{
                                		cvsMappedBeanObj.setMIG_APPL_SHORT_NAME("AU");
                               	 	}
                                	if(cvsMappedBeanObj.getMIG_FORM_APPLICATION_TOP() == null)
                                	{
                                		cvsMappedBeanObj.setMIG_FORM_APPLICATION_TOP("AU_TOP");
                                	}
                                	
                                }
                                
                                if(isIdempierePackInObject(objectType))
                                {
                                	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                                			+ cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                                	if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                                	{
                                		if(! cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME().toLowerCase().endsWith(".zip") )
                                		{
                                			System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                                			msg.append("\n ");
                                			msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                			msg.append("\n");
                                			msg.append("      [ERROR]: OBJECT TYPE " + objectType + " SUPPORTS ONLY '.zip' FILE.\n ");
                                			returnFlag = false;
                                		}
                                	}
                                }
                                
                                
                                try
                                {
                                    if(objectVersionString != null)
                                    {
                                        objectVersionDoubleValue = Double.parseDouble(objectVersionString);
                                        System.out.println("Tri2ModelValidator.startValidationProcess()....objectVersionDoubleValue :: "
                                                + objectVersionDoubleValue);
                                    }
                                    else
                                    {
                                        msg.append("\n ");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n ");
                                        // msg.append("\n " +
                                        // cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME()
                                        // + "\n");
                                        msg.append("      [ERROR]:  Please enter object version number for the object [");
                                        msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("]");
                                        returnFlag = false;
                                    }

                                }
                                catch(NumberFormatException e)
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess().... ::: Version is not a Double Value"
                                            + e.getMessage());
                                    e.printStackTrace();
                                }
                                catch(Exception e)
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()"
                                            + e.getMessage());
                                    e.printStackTrace();
                                }
                                /*
                                 *  IS086656 - i. Need LOV for Language for XML PUB reports migration. 
                                 *  ii. Make LOB_TYPE and XDO_FILE_TYPE as mandatory for XML_PUB_REPORTS migration.
                                 *  Logic to clear language which is set by default to 'en' even if object type is
                                 *  other than XML_PUB_REPORTS
                                 */
                                if((!objectType.equalsIgnoreCase("XML_PUB_REPORTS")) && cvsMappedBeanObj.getLANGUAGE() != null)
                                {
                                	cvsMappedBeanObj.setLANGUAGE(null);
                                }
                                else if(cvsMappedBeanObj.getLANGUAGE() == null)
                                {
                                	cvsMappedBeanObj.setLANGUAGE("en");
                                }
                                /**
                                 * IS112542 - While migration of Execute shell script object type, right now the target path is not being captured in migration log though provided.
                                 * */
                                if(objectType.equalsIgnoreCase("EXECUTE_SHELL SCRIPT") && cvsMappedBeanObj.getTEMP_BASE_PATH() != null)
                                {
                                	cvsMappedBeanObj.setMIG_FORM_APPLICATION_TOP(cvsMappedBeanObj.getTEMP_BASE_PATH());
                                }
                            }
                        }
                        else
                        {
                            msg.append("      [ERROR]: Please provide all required fields for '");
                            if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null && !cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME().equalsIgnoreCase(""))
                            {
                                msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            }
                            else
                            {
                                msg.append("Map CVS objects");
                            }
                            msg.append("'.\n\n");
                            returnFlag = false;
                        }
                        /**
                         * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                         */
                        if(cvsMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (cvsMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                        {
                            if(!atleastOneMigrateFlagChecked)
                            {
                                atleastOneMigrateFlagChecked = true;
                            }
                        }
                    }
                    /*else
                    {
                        if(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                        {
                            msg.append("\n ");
                            msg.append(cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                        }
                        msg.append("\n");
                        msg.append("      [ERROR]: OBJECT TYPE is mandatory for the object in Map CVS objects.\n");
                        returnFlag = false;
                    }*/
                    
                    /**
                     * IS090169 - Provide depend on feature for migrations in AOM
                     */
//                    migrationSequence = cvsMappedBeanObj.getMIG_MIGRATION_SEQUENCE();
//                    migrationSequences.add(migrationSequence);
//                    
//                    dependOn = cvsMappedBeanObj.getDEPEND_ON();
//                    dependOns.add(dependOn);
//                    System.out.println("Tri2ModelValidator.startValidationProcess()(Map CVS Objects)...migrationSequence:" + migrationSequence
//                            + ", dependOn:" + dependOn);
                }
                	migrationSequence = cvsMappedBeanObj.getMIG_MIGRATION_SEQUENCE();
                    migrationSequences.add(migrationSequence);
                    
                    dependOn = cvsMappedBeanObj.getDEPEND_ON();
                    dependOns.add(dependOn);
                    
                    /**
                     * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
                     */
                    
                    onSuccess = cvsMappedBeanObj.getON_SUCCESS();
				    onSuccesses.add(onSuccess);
				    successMap.put(migrationSequence, onSuccess);
				    onFailure = cvsMappedBeanObj.getON_FAILURE();
				    onFailures.add(onFailure);
				    failureMap.put(migrationSequence, onFailure);
                    System.out.println("Tri2ModelValidator.startValidationProcess()(Map CVS Objects)...migrationSequence:" + migrationSequence
                            + ", dependOn:" + dependOn);
                    System.out.println("Tri2ModelValidator.startValidationProcess()(Upload Objects)...onSuccess:" + onSuccess
	                        + ", onFailure:" + onFailure);
            }
        }

        // 'Map SVN Objects' tab
        if(svnMappedMigDetails != null && lengthOfSvnMappedObjBeanArr > 0)
        {
        	 Boolean autoFillTopAndShortNameflag = false;
            for(int svnObjectsIndex = 0; svnObjectsIndex < lengthOfSvnMappedObjBeanArr; svnObjectsIndex ++ )
            {
                svnMappedBeanObj = svnMappedMigDetails[svnObjectsIndex];
                //IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                if(svnMappedBeanObj != null)
                {
                	solutionObjectIdList.add(svnMappedBeanObj.getMIG_DEV_ISSUE_SOLUTION_OBJECT_ID());
                }
                isObjectAvailable = true;
                if(!isSolutionObjectAttached)
                {
                    isSolutionObjectAttached = true;
                }
                
                if(svnMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (svnMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }

                
                if(svnMappedBeanObj != null && (svnMappedBeanObj.getOBJECT_MODIFIED() != null && svnMappedBeanObj.getOBJECT_MODIFIED().equalsIgnoreCase("Y")) && svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                {
                    String svnObjectName = null;
                    String svnOldObjectName = null;

                    String svnObjectExpectedPath = svnMappedBeanObj.getMIG_DEV_OBJECT_EXPECTED_PATH();
                    String svnObjectExpectedExtension = svnMappedBeanObj.getMIG_DEV_FILE_EXTENSION();

                    String onlinePatchingMode = null;
                    if(svnMappedBeanObj.getONLINE_PATCH_MODE() != null && svnMappedBeanObj.getONLINE_PATCH_MODE().booleanValue())
                    {
                        onlinePatchingMode = "true";  
                    }
                    else
                    {
                        onlinePatchingMode = "false"; 
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map SVN onlinePatchMode:" + onlinePatchingMode);
                    String editioned = null;
                    if(svnMappedBeanObj.getEDITIONED() != null)
                    {
                        editioned = svnMappedBeanObj.getEDITIONED();
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map SVN editioned:" + editioned);
                    if(!(editioned != null && !editioned.trim().equalsIgnoreCase("")
                            && editioned.equalsIgnoreCase("Yes")))
                    {
                        editioned = "No";
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map SVN modified editioned:" + editioned);

                    Boolean errorFlag = true;

                    if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null 
                            && svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                    {
                        if(svnObjectExpectedPath != null
                                && ! svnObjectExpectedPath.equalsIgnoreCase(""))
                        {
                            String[] svnMultiObjectExpectedPath = svnObjectExpectedPath.split(",");
                            String fileName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                            System.out.println("Tri2ModelValidator.startValidationProcess()...Map SVN fileName:" + fileName);
                            String objectType = svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            int lastIndexOfSlash = fileName.lastIndexOf("/");

                            String objectFolderPath = fileName.substring(0, lastIndexOfSlash);
                            String configuredPath = null;
                            for(int index = 0; index < svnMultiObjectExpectedPath.length; index ++ )
                            {
                                configuredPath = svnMultiObjectExpectedPath[index];
                                if (configuredPath != null && configuredPath.endsWith("/"))
                                {
                                    configuredPath = configuredPath.substring(0, configuredPath.length() - 1);
                                }
                                if(objectFolderPath.equals(configuredPath))
                                {
                                    errorFlag = false;
                                    break;
                                }
                            }

                            if(errorFlag)
                            {
                                msg.append("\n ");
                                msg.append(objectType);
                                msg.append(" :- ");
                                msg.append(fileName);
                                msg.append("\n ");
                                msg.append("[ERROR]:  Above attached object is not mapped from the expected path.\nPlease commit this object in correct path of Repository and map again. ");
                                msg.append("\n ");
                                msg.append("Expected path :- '");
                                msg.append(svnObjectExpectedPath);
                                msg.append("'.\n");

                                returnFlag = false;
                                System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Svn ::: "
                                        + msg + "   FLAG : " + returnFlag);
                            }

                        }
                        errorFlag = true;
                        if(svnObjectExpectedExtension != null
                                && ! svnObjectExpectedExtension.equalsIgnoreCase(""))
                        {
                            String[] svnMultiObjectExpectedExtension = svnObjectExpectedExtension.split(",");
                            String fileName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                            String objectType = svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            int n = fileName.lastIndexOf('.');
                            int length = fileName.length();
                            String  expectedExtension = fileName.substring(n+1,length);
                            System.out.println(expectedExtension);
                            for(int i = 0; i < svnMultiObjectExpectedExtension.length; i ++ )
                            {
                                if(expectedExtension.equalsIgnoreCase(svnMultiObjectExpectedExtension[i]))
                                {
                                    errorFlag = false;
                                    break;
                                }
                            }

                            if(errorFlag)
                            {
                                msg.append("\n ");
                                msg.append(objectType);
                                msg.append(" :- ");
                                msg.append(fileName);
                                msg.append("\n ");
                                msg.append("[ERROR]:Please Provide correct extension for above object. ");
                                msg.append("\n ");
                                msg.append("Expected Extension :- '");
                                msg.append(svnObjectExpectedExtension);
                                msg.append("'.\n");

                                returnFlag = false;
                                System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Cvs ::: "
                                        + msg + "   FLAG : " + returnFlag);
                            }
                        }

                    }
                    /**
                     * Checking selected Object Type as it is mandatory 
                     */
                    if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null
                            || svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;
                        }
                        isAtleastOneObjectModified = true;
                        svnObjectName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                        svnOldObjectName = svnMappedBeanObj.getMIG_DEV_OLD_OBJECT_NAME();
                        System.out.println("Tri2ModelValidator.startValidationProcess()...svnObjectName:" + svnObjectName);
                        if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null
                                && svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                        {
                            /**
                             * IS066428 Provide an easy way to re-map an object with
                             * its latest version in Attach Solution Objects page
                             */
                            Boolean latestVersionFlagChecked = svnMappedBeanObj.getLATEST_VERSION_FLAG();
                            if(latestVersionFlagChecked != null
                                    && latestVersionFlagChecked.booleanValue()
                                    && svnObjectName.equals(svnOldObjectName))
                            {
                                String latestVersion = svnMappedBeanObj.getMIG_DEV_OBJECT_LATEST_VERSION();
                                if(latestVersion != null)
                                {
                                    svnMappedBeanObj.setMIG_DEV_OBJECT_VERSION(latestVersion);
                                }
                            }
                            this.validateFileExtension(svnMappedBeanObj);

                            String objectType = svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            String copyBasePath = svnMappedBeanObj.getTEMP_BASE_PATH();
                            String objectVersionString = svnMappedBeanObj.getMIG_DEV_OBJECT_VERSION();
                            String objectDownloadSource = svnMappedBeanObj.getMIG_OBJ_DOWNLOAD_SOURCE();
                            double objectVersionDoubleValue = 0;

                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectType(MapSVN):" + objectType);
                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectDownloadSource(MapSVN):" + objectDownloadSource);

                            if(objectType != null)
                            {
                            	boolean isSQLObject = false;
                                if(isSchemaRequired(objectType))
                                {
                                    if(svnMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(svnObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' is mandatory for "+ objectType +" object.\n      Select 'Schema' for '");
                                        msg.append(svnObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;

                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Svn ::: "
                                                + msg + "   FLAG : " + returnFlag);
                                    }
                                    isSQLObject = isSQLObjectType(objectType); // IS110822 - Added to make the SQL Line width validation as thread based
                                    if(isSQLObject && svnMappedBeanObj.getDATABASE_TYPE() == null && validateDatabaseType)
                                    {
                                        msg.append("\n ");
                                        msg.append(svnObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Database Type' is mandatory as workflow contains target instances with different database types.\n      Select 'Database Type' for '");
                                        msg.append(svnObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... Database Type Svn ::: " +  msg  + " FLAG : " + returnFlag);
                                    }
                                }
                                HashMap beanObjectData = new HashMap();
                                if(validateExtractFile.equals("true"))
                                {
                                	
                                    System.out.println("Inside SVN, SQL file each line length validation flag is true.");
                                    String projectPathName = null;
                                    int lastSlash = svnObjectName.lastIndexOf("/");
                                    String objectPath = null;
                                    if(lastSlash != - 1)
                                    {
                                        objectPath = svnObjectName.substring(0, lastSlash);
                                        projectPathName = objectPath;
                                        svnObjectName = svnObjectName.substring(lastSlash + 1, svnObjectName.length());
                                    }
                                    
                                    beanObjectData.put("svnMappedBeanObj", svnMappedBeanObj);
                                    beanObjectData.put("attachedFrom", "mapSVN");
                                    beanObjectData.put("svnObjectName", svnObjectName);
                                    beanObjectData.put("svnObjectVersion", objectVersionString);
                                    beanObjectData.put("svnProjectModule", projectPathName);
                                    beanObjectData.put("svnType", objectDownloadSource);
                                    beanObjectData.put("objectType", objectType);
                                    beanObjectData.put("isSQLObject", isSQLObject);// IS110822 - Added to make the SQL Line width validation as thread based
                                    beanObjectData.put("issueNumber", issueNumber);
                                    /**
                                     * IS079554 - Need to parse all the objects to check whether it is editioned or non-editioned and migrate 
                                     *            all objects to patch edition if any of the object is editioned object in a migration
                                     */
                                    beanObjectData.put("onlinePatchingMode", onlinePatchingMode);
                                    beanObjectData.put("beanIndex", Integer.toString(svnObjectsIndex));
                                    System.out.println("Tri2ModelValidator.startValidationProcess() beanObjectData::" + beanObjectData);
                                    if(isAOLObject(objectType))
                                    {
                                    	System.out.println(svnObjectName + " is adding for AOL Objects ");
                                    	allSQLObjectsDataMap.put("mapSVN_" + Integer.toString(svnObjectsIndex), beanObjectData);
                                    }
                                    if(isValidationRequired(objectType))
                                    {
                                        System.out.println(svnObjectName
                                                + " is adding for SQL file each line length validation. ");
                                        allSQLObjectsDataMap.put("mapSVN_" + Integer.toString(svnObjectsIndex), beanObjectData);
                                    }
                                    /**
                                     * IS080795 Validation of Oracle objects in TRI2 Migration Tool based on editioned/non-editioned 
                                     * if Target instance is configured for Online Patching migrations
                                     */
                                    else if(isOnlinePatchingEnabledForTargetInstanceFlag)
                                    {
                                        System.out.println("Tri2ModelValidator.startValidationProcess()...other than SQL in Map SVN!");
                                        beanObjectData.put("editioned", editioned);
                                        allOtherObjectsExceptSQL.put("mapSVN_" + Integer.toString(svnObjectsIndex), beanObjectData);
                                    }

                                }
                                
                                
                                /*if(objectType.equalsIgnoreCase("JAR"))
                                {
                                    String objectName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                    if( ! objectName.endsWith(".zip"))
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        msg.append("[ERROR]: OBJECT TYPE 'JAR' SUPPPORTS ONLY '.zip' FILE.\n ");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Svn ::: "
                                                + msg + "   FLAG : " + returnFlag);
                                    }
                                }*/

                                /**
                                 * IS068210:Migration of Integration repository
                                 * objects through AOM
                                 */
                                /*if(objectType.equalsIgnoreCase("INTEGRATION_REPOSITORY_OBJECT"))
                                {
                                    String objectName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                    if( ! objectName.endsWith(".ildt"))
                                    {
                                        msg.append("\n ");
                                        msg.append(objectName);
                                        msg.append("\n ");
                                        msg.append("[ERROR]: OBJECT TYPE 'INTEGRATION_REPOSITORY_OBJECT' SUPPPORTS ONLY '.ildt' FILE.\n ");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Svn ::: "
                                                + msg + "   FLAG : " + returnFlag);
                                    }
                                }*/
                                if(objectType.equalsIgnoreCase("BA_FOLDER")
                                        || objectType.equalsIgnoreCase("BUSINESS_AREA")
                                        || objectType.equalsIgnoreCase("WORKBOOK"))
                                {
                                    if(svnMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' IS MANDATORY FOR DISCOVERER OBJECTS.\n      Select 'Schema' for '");
                                        msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Svn ::: "
                                                + msg + "   FLAG : " + returnFlag);
                                    }
                                    if(svnMappedBeanObj.getORA_DISC_EUL_NAME() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(svnObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'EUL Name' IS MANDATORY FOR OBJECTS.\n      Select 'EUL Name' for '");
                                        msg.append(svnObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                    }
                                }
                                /*
                                 *  IS086656 - i. Need LOV for Language for XML PUB reports migration. 
                                 *  ii. Make LOB_TYPE and XDO_FILE_TYPE as mandatory for XML_PUB_REPORTS migration.
                                 *  Logic to clear language which is set by default to 'en' even if object type is
                                 *  other than XML_PUB_REPORTS
                                 */
                                if((!objectType.equalsIgnoreCase("XML_PUB_REPORTS")) && svnMappedBeanObj.getLANGUAGE() != null)
                                {
                                	svnMappedBeanObj.setLANGUAGE(null);
                                }
                                else if(svnMappedBeanObj.getLANGUAGE() == null)
                                {
                                	svnMappedBeanObj.setLANGUAGE("en");
                                }
                            }

                            if(isObjectTypeAvailable(objectType))
                            {
                                if(svnMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                {
                                    svnMappedBeanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                }
                                String fetchShortNameAndTopNameFromLDTFile = null;
                                boolean flag = false;
                                ResourceBundle resourceBundle = ResourceBundle.getBundle("ContextPath");
                                String tri2URL = resourceBundle.getString("tri2MigrationServleturl");
                            	String propKey = "ShortNameNTopNameFetchFromFileOrNot";
                            	String patternName = null;
                                if(resourceBundle != null)
                                {
                                	
                                	fetchShortNameAndTopNameFromLDTFile = (String)getThePropertyValueOrCheckingPatternForAOLObject(tri2URL,propKey,flag);
                                	System.out.println("Tri2ModelValidator.startValidationProcess() FOR MapSVN..fetchShortNameAndTopNameFromLDTFile : "+fetchShortNameAndTopNameFromLDTFile );

                                }
                                
                                if(fetchShortNameAndTopNameFromLDTFile != null && fetchShortNameAndTopNameFromLDTFile.equalsIgnoreCase("True"))
                                {
                                	flag = true;
                                	
                                	HashMap commPatternobjTypInDBData = (HashMap)getThePropertyValueOrCheckingPatternForAOLObject(tri2URL,objectType,flag);
                                	System.out.println("Tri2ModelValidator.startValidationProcess() FOR MapSVN..commPatternobjTypInDBtrueOrFalse : "+commPatternobjTypInDBData);
                                	
                                	autoFillTopAndShortNameflag = (Boolean)commPatternobjTypInDBData.get("patternFoundOrNot");
                                	if(autoFillTopAndShortNameflag.booleanValue())
                                	{
                                		patternName = (String) commPatternobjTypInDBData.get("patternForOracleTop");
                                	}
                                
                                }
                              
                                HashMap beanObjectData = (HashMap) allOtherObjectsExceptSQL.get("mapSVN_" + Integer.toString(svnObjectsIndex));

                                beanObjectData.put("autoFillTopAndShortNameflag", autoFillTopAndShortNameflag);
                                beanObjectData.put("patternName", patternName);

                                allOtherObjectsExceptSQL.put("mapSVN_" + Integer.toString(svnObjectsIndex), beanObjectData);

                                if(!autoFillTopAndShortNameflag.booleanValue())
                                {
                                	 if((svnMappedBeanObj.getMIG_APPL_SHORT_NAME() == null || svnMappedBeanObj.getMIG_FORM_APPLICATION_TOP() == null)
                                             && this.isApplicationTopRequired(objectType))
                                     {
                                         msg.append("\n ");
                                         msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                         msg.append("\n ");
                                         // msg.append("\n " +
                                         // svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() +
                                         // "\n");
                                         msg.append("      [ERROR]: 'Oracle Application Top' AND 'Oracle Application Short Name' ARE MANDATORY FOR AOL OBJECTS.\n      Select 'Oracle Application Top' AND 'Oracle Application Short Name' for '");
                                         msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                         msg.append("'.\n");
                                         returnFlag = false;
                                         System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Svn ::: "
                                                 + msg + "   FLAG : " + returnFlag);
                                     }
                                }
                                

                               
                                /**
                                 * IS063446-AOM to support xml pub reports
                                 * migration.
                                 */
                                /*
                                 *  IS086656 - i. Need LOV for Language for XML PUB reports migration. 
                                 *  ii. Make LOB_TYPE and XDO_FILE_TYPE as mandatory for XML_PUB_REPORTS migration.
                                 */
                                if(objectType.equalsIgnoreCase("XML_PUB_REPORTS"))
                                {
                                	if(!(svnMappedBeanObj.getLOB_CODE() != null && ! svnMappedBeanObj.getLOB_CODE().equalsIgnoreCase(""))
                                			|| !(svnMappedBeanObj.getLOB_TYPE() != null && ! svnMappedBeanObj.getLOB_TYPE().equalsIgnoreCase(""))
                                			|| !(svnMappedBeanObj.getXDO_FILE_TYPE() != null && ! svnMappedBeanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                	{
                                		msg.append("\n ");
                                		msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("\n");
                                	}
                                	if(!(svnMappedBeanObj.getLOB_CODE() != null && ! svnMappedBeanObj.getLOB_CODE().equalsIgnoreCase("")))
                                	{
                                		msg.append("      [ERROR]: 'LOB Code' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Code' for '");
                                		msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("'.\n");
                                		returnFlag = false;
                                	}
                                	if(!(svnMappedBeanObj.getLOB_TYPE() != null && ! svnMappedBeanObj.getLOB_TYPE().equalsIgnoreCase("")))
                                	{ 
                                		msg.append("\n      [ERROR]: 'LOB Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Type' for '");
                                		msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("'.\n");
                                		returnFlag = false;
                                	}
                                	if(!(svnMappedBeanObj.getXDO_FILE_TYPE() != null && ! svnMappedBeanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                	{ 
                                		msg.append("\n      [ERROR]: 'XDO File Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'XDO File Type' for '");
                                		msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("'.\n");
                                		returnFlag = false;
                                	}
                                }

                                if(objectType.equalsIgnoreCase("ORACLE_WORKFLOW")
                                        && svnMappedBeanObj.getOracleWorkFlowUploadMode() == null)
                                {
                                    msg.append("\n ");
                                    msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    // msg.append("\n " +
                                    // svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() +
                                    // "\n");
                                    msg.append("      [ERROR]: 'Oracle WorkFlow Upload Mode' IS MANDATORY FOR ORACLE WORKFLOW MIGRATION,SELECT MODE VALUE FORM LIST OF VALUES OF 'OracleWorkflow Upload Mode'.\n");
                                    returnFlag = false;
                                }
                            }

                            /**
                             * @author skolla IS068968 Provide a feature to migrate
                             *         the Info Lease Objects through TRI2
                             */
                            if(objectType.equalsIgnoreCase("INFOLEASE_DICTIONARY_OBJECTS"))
                            {
                                String objectName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                if(svnMappedBeanObj.getDESTINATION_DICTIONARY_FILE() == null
                                        || svnMappedBeanObj.getDICTIONARY_RECORD_IDS() == null)
                                {
                                    msg.append("\n ");
                                    msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());

                                    if(svnMappedBeanObj.getDESTINATION_DICTIONARY_FILE() == null)
                                    {
                                        msg.append("\n");
                                        msg.append("\n");
                                        msg.append("      [ERROR]: Target Dictionary File Name is mandatory for object type 'INFOLEASE_DICTIONARY_OBJECTS'.\n\n      Please provide valid Target file name in 'Target Dictionary File' field. \n \n");
                                    }

                                    if(svnMappedBeanObj.getDICTIONARY_RECORD_IDS() == null)
                                    {
                                        msg.append("\n");
                                        msg.append("\n");
                                        msg.append("      [ERROR]: DictionaryRecord Id's is mandatory for object type 'INFOLEASE_DICTIONARY_OBJECTS'.\n\n      Please provide valid Dictionary Record Id's (for multiple record id's provide comma separated values ) in 'Dictionary Record Id's' field. \n\n");
                                    }
                                    returnFlag = false;
                                }
                            }

                            if(objectType.equalsIgnoreCase("COPY")
                                    || objectType.equalsIgnoreCase("COPY AND EXTRACT")
                                    || objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                    || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                    || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")
                                    || objectType.equalsIgnoreCase("SOFTLINK")
                            	
                                    //IS111135 - Migration of OAF Objects getting failed when mapped from CVS/SVN/GIT tabs
                                    
                                    || objectType.equalsIgnoreCase("OAF-COPY")
                                    || objectType.equalsIgnoreCase("OAF-WEB_UI")
                                    || objectType.equalsIgnoreCase("OAF_STANDARD-JPX")
                                    || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-COPY")
                                    || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-WEB_UI"))
                            {
                                String objectName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                /*if(objectType.equalsIgnoreCase("COPY AND EXTRACT"))
                                {
                                    if(objectName != null)
                                    {
                                        if( ! objectName.endsWith(".zip"))
                                        {
                                            System.out.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.zip) :: ");
                                            msg.append("\n ");
                                            msg.append(objectName);
                                            msg.append("\n");
                                            // msg.append("\n " +
                                            // beanObj.getMIG_DEV_OBJECT_NAME() +
                                            // "\n");
                                            msg.append("      [ERROR]: OBJECT TYPE 'COPY AND EXTRACT' SUPPPORTS ONLY '.zip' FILE.\n ");
                                            returnFlag = false;
                                        }
                                    }
                                }
                                 */
                                if(copyBasePath == null)
                                {
                                    msg.append("\n ");
                                    msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    // msg.append("\n " +
                                    // svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() +
                                    // "\n");
                                    /*msg.append("      [ERROR]: Target directory path is mandatory for object type '"+ objectType+"'.\n      Provide valid path in 'Target Path' field. \n      For Reference :: '$XX_TOP/bin/..etc.' \n");
                                    returnFlag = false;
                                    System.out.println("Tri2ModelValidator.startValidationProcess().... COPY Svn ::: "
                                            + msg);*/

                                    msg.append("      [ERROR]: Target directory folder is mandatory for object type '"
                                            + objectType);

                                    if((objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                            || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                            || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")))
                                    {

                                        if(objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS"))
                                        {
                                            msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'USER.DEFINED.BP' \n");
                                        }
                                        else if(objectType.equalsIgnoreCase("INFOLEASE_REPORTS"))
                                        {
                                            msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'RECALLS' \n");
                                        }
                                        else if(objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS"))
                                        {
                                            msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'njs' \n");
                                        }
                                    }
                                    else
                                    {
                                        msg.append("'.\n      Provide valid path in 'Target Path' field. \n      For Reference :: '$XX_TOP/bin/..etc.' \n\n");
                                    }
                                    returnFlag = false;
                                }
                                else
                                {
                                    svnMappedBeanObj.setMIG_FORM_APPLICATION_TOP(copyBasePath);
                                }
                            }

                            if(objectType.equalsIgnoreCase("ORACLE_PATCH"))
                            {
                                if(svnMappedBeanObj.getORA_SYSTEM_PWD() == null
                                        || svnMappedBeanObj.getORACLE_PATCH_NUMBER() == null)
                                {
                                    msg.append("\n ");
                                    msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    // msg.append("\n " +
                                    // svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() +
                                    // "\n");
                                    msg.append("      [ERROR]: PLEASE PROVIDE ORACLE SYSTEM USER PASSWORD AND ORACLE PATCH NUMBER.");
                                    returnFlag = false;
                                }
                            }
                            
                            /**
                             * IS092334 - Provision to map idempiere objects from CVS and SVN to migrate.
                             */
                            if(objectType.equalsIgnoreCase("IDEMPIERE_BUNDLE"))
                            {
                            	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                            			+ svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                            	if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                            	{
                            		if(! svnMappedBeanObj.getMIG_DEV_OBJECT_NAME().toLowerCase().endsWith(".jar") )
                            		{
                            			System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                            			msg.append("\n ");
                            			msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            			msg.append("\n");
                            			msg.append("      [ERROR]: OBJECT TYPE " + objectType + " SUPPORTS ONLY '.jar' FILE.\n ");
                            			returnFlag = false;
                            		}
                            	}
                            }
                            
                            //IS097480 - Provision to migrate oracle form libraries (custom.pll) through AOM
                            if("ORACLE_FORM_LIBRARIES".equalsIgnoreCase(objectType))
                            {
                            	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                            			+ svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                            	if(svnMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                {
                            		svnMappedBeanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                }
                            	if(svnMappedBeanObj.getMIG_APPL_SHORT_NAME() == null)
                           	 	{
                            		svnMappedBeanObj.setMIG_APPL_SHORT_NAME("AU");
                           	 	}
                            	if(svnMappedBeanObj.getMIG_FORM_APPLICATION_TOP() == null)
                            	{
                            		svnMappedBeanObj.setMIG_FORM_APPLICATION_TOP("AU_TOP");
                            	}
                            }
                            /**
                             * IS112542 - While migration of Execute shell script object type, right now the target path is not being captured in migration log though provided.
                             * */
                            if(objectType.equalsIgnoreCase("EXECUTE_SHELL SCRIPT") && svnMappedBeanObj.getTEMP_BASE_PATH() != null)
                            {
                            	svnMappedBeanObj.setMIG_FORM_APPLICATION_TOP(svnMappedBeanObj.getTEMP_BASE_PATH());
                            }
                            if(isIdempierePackInObject(objectType))
                            {
                            	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                            			+ svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                            	if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                            	{
                            		if(! svnMappedBeanObj.getMIG_DEV_OBJECT_NAME().toLowerCase().endsWith(".zip") )
                            		{
                            			System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                            			msg.append("\n ");
                            			msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            			msg.append("\n");
                            			msg.append("      [ERROR]: OBJECT TYPE " + objectType + " SUPPORTS ONLY '.zip' FILE.\n ");
                            			returnFlag = false;
                            		}
                            	}
                            }

                            try
                            {
                                if(objectVersionString != null)
                                {
                                    objectVersionDoubleValue = Double.parseDouble(objectVersionString);
                                    System.out.println("Tri2ModelValidator.startValidationProcess()....objectVersionDoubleValue :: "
                                            + objectVersionDoubleValue);
                                }
                                else
                                {
                                    msg.append("\n ");
                                    msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    // msg.append("\n " +
                                    // svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() +
                                    // "\n");
                                    msg.append("      [ERROR]:  Please enter object version number for the object [");
                                    msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("]");
                                    returnFlag = false;
                                }

                            }
                            catch(NumberFormatException e)
                            {
                                System.out.println("Tri2ModelValidator.startValidationProcess().... ::: Version is not a Double Value"
                                        + e.getMessage());
                                e.printStackTrace();
                            }
                            catch(Exception e)
                            {
                                System.out.println("Tri2ModelValidator.startValidationProcess()"
                                        + e.getMessage());
                                e.printStackTrace();
                            }
                        }
                        else
                        {
                            msg.append("      [ERROR]: Please provide all required fields for '");
                            if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null && !svnMappedBeanObj.getMIG_DEV_OBJECT_NAME().equalsIgnoreCase(""))
                            {
                                msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            }
                            else
                            {
                                msg.append("Map SVN objects.");
                            }
                            msg.append("'.\n\n");
                            returnFlag = false;
                        }
                        /*
                         * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                         */
                        if(svnMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (svnMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                        {
                            if(!atleastOneMigrateFlagChecked)
                            {
                                atleastOneMigrateFlagChecked = true;
                            }
                        }  
                    }
                    
                    /*else
                    {
                        if(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                        {
                            msg.append("\n ");
                            msg.append(svnMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                        }
                        msg.append("\n");
                        msg.append("      [ERROR]: OBJECT TYPE is mandatory for the object in Map SVN objects.\n");
                        returnFlag = false;
                    }*/
                    
                    /**
                     * IS090169 - Provide depend on feature for migrations in AOM
                     */
//                    migrationSequence = svnMappedBeanObj.getMIG_MIGRATION_SEQUENCE();
//                    migrationSequences.add(migrationSequence);
//                    
//                    dependOn = svnMappedBeanObj.getDEPEND_ON();
//                    dependOns.add(dependOn);
//                    System.out.println("Tri2ModelValidator.startValidationProcess()(Map SVN Objects)...migrationSequence:" + migrationSequence
//                            + ", dependOn:" + dependOn);
                }
                migrationSequence = svnMappedBeanObj.getMIG_MIGRATION_SEQUENCE();
                migrationSequences.add(migrationSequence);
                
                dependOn = svnMappedBeanObj.getDEPEND_ON();
                dependOns.add(dependOn);
                
                /**
                 * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
                 */
                
                onSuccess = svnMappedBeanObj.getON_SUCCESS();
			    onSuccesses.add(onSuccess);
			    successMap.put(migrationSequence, onSuccess);
			    onFailure = svnMappedBeanObj.getON_FAILURE();
			    onFailures.add(onFailure);
			    failureMap.put(migrationSequence, onFailure);
			    
                System.out.println("Tri2ModelValidator.startValidationProcess()(Map SVN Objects)...migrationSequence:" + migrationSequence
                        + ", dependOn:" + dependOn);
                System.out.println("Tri2ModelValidator.startValidationProcess()(Upload Objects)...onSuccess:" + onSuccess
                        + ", onFailure:" + onFailure);
            }
        }
        
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        // 'Map GIT Objects' tab
        if(gitMappedMigDetails != null && lengthOfGitMappedObjBeanArr > 0)
        {
            for(int gitObjectsIndex = 0; gitObjectsIndex < lengthOfGitMappedObjBeanArr; gitObjectsIndex ++ )
            {
            	gitMappedBeanObj = gitMappedMigDetails[gitObjectsIndex];
            	//IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
            	if(gitMappedBeanObj != null)
                {
                	solutionObjectIdList.add(gitMappedBeanObj.getMIG_DEV_ISSUE_SOLUTION_OBJECT_ID());
                }
            	isObjectAvailable = true;
            	if(!isSolutionObjectAttached)
                {
                    isSolutionObjectAttached = true;
                }
            	
            	if(gitMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (gitMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }

            	if(gitMappedBeanObj != null && (gitMappedBeanObj.getOBJECT_MODIFIED() != null && gitMappedBeanObj.getOBJECT_MODIFIED().equalsIgnoreCase("Y")) && gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                {
                    String gitObjectName = null;
                    String gitOldObjectName = null;

                    String gitObjectExpectedPath = gitMappedBeanObj.getMIG_DEV_OBJECT_EXPECTED_PATH();
                    String gitObjectExpectedExtension = gitMappedBeanObj.getMIG_DEV_FILE_EXTENSION();

                    String onlinePatchingMode = null;
                    if(gitMappedBeanObj.getONLINE_PATCH_MODE() != null && gitMappedBeanObj.getONLINE_PATCH_MODE().booleanValue())
                    {
                        onlinePatchingMode = "true";  
                    }
                    else
                    {
                        onlinePatchingMode = "false"; 
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map GIT onlinePatchMode:" + onlinePatchingMode);
                    String editioned = null;
                    if(gitMappedBeanObj.getEDITIONED() != null)
                    {
                        editioned = gitMappedBeanObj.getEDITIONED();
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map GIT editioned:" + editioned);
                    if(!(editioned != null && !editioned.trim().equalsIgnoreCase("")
                            && editioned.equalsIgnoreCase("Yes")))
                    {
                        editioned = "No";
                    }
                    System.out.println("Tri2ModelValidator.startValidationProcess()...Map GIT modified editioned:" + editioned);

                    Boolean errorFlag = true;

                    if(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null 
                            && gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                    {
                        if(gitObjectExpectedPath != null
                                && ! gitObjectExpectedPath.equalsIgnoreCase(""))
                        {
                            String[] gitMultiObjectExpectedPath = gitObjectExpectedPath.split(",");
                            String fileName = gitMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                            System.out.println("Tri2ModelValidator.startValidationProcess()...Map GIT fileName:" + fileName);
                            String objectType = gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            int lastIndexOfSlash = fileName.lastIndexOf("/");

                            String objectFolderPath = fileName.substring(0, lastIndexOfSlash);
                            String configuredPath = null;
                            for(int index = 0; index < gitMultiObjectExpectedPath.length; index ++ )
                            {
                                configuredPath = gitMultiObjectExpectedPath[index];
                                if (configuredPath != null && configuredPath.endsWith("/"))
                                {
                                    configuredPath = configuredPath.substring(0, configuredPath.length() - 1);
                                }
                                if(objectFolderPath.equals(configuredPath))
                                {
                                    errorFlag = false;
                                    break;
                                }
                            }

                            if(errorFlag)
                            {
                                msg.append("\n ");
                                msg.append(objectType);
                                msg.append(" :- ");
                                msg.append(fileName);
                                msg.append("\n ");
                                msg.append("[ERROR]:  Above attached object is not mapped from the expected path.\nPlease commit this object in correct path of Repository and map again. ");
                                msg.append("\n ");
                                msg.append("Expected path :- '");
                                msg.append(gitObjectExpectedPath);
                                msg.append("'.\n");

                                returnFlag = false;
                                System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Git ::: "
                                        + msg + "   FLAG : " + returnFlag);
                            }

                        }
                        errorFlag = true;
                        if(gitObjectExpectedExtension != null
                                && ! gitObjectExpectedExtension.equalsIgnoreCase(""))
                        {
                            String[] gitMultiObjectExpectedExtension = gitObjectExpectedExtension.split(",");
                            String fileName = gitMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                            String objectType = gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            int n = fileName.lastIndexOf('.');
                            int length = fileName.length();
                            String  expectedExtension = fileName.substring(n+1,length);
                            System.out.println(expectedExtension);
                            for(int i = 0; i < gitMultiObjectExpectedExtension.length; i ++ )
                            {
                                if(expectedExtension.equalsIgnoreCase(gitMultiObjectExpectedExtension[i]))
                                {
                                    errorFlag = false;
                                    break;
                                }
                            }

                            if(errorFlag)
                            {
                                msg.append("\n ");
                                msg.append(objectType);
                                msg.append(" :- ");
                                msg.append(fileName);
                                msg.append("\n ");
                                msg.append("[ERROR]:Please Provide correct extension for above object. ");
                                msg.append("\n ");
                                msg.append("Expected Extension :- '");
                                msg.append(gitObjectExpectedExtension);
                                msg.append("'.\n");

                                returnFlag = false;
                                System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Git ::: "
                                        + msg + "   FLAG : " + returnFlag);
                            }
                        }

                    }
                    if(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null
                            || gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;
                        }
                        isAtleastOneObjectModified = true;
                        gitObjectName = gitMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                        gitOldObjectName = gitMappedBeanObj.getMIG_DEV_OLD_OBJECT_NAME();
                        System.out.println("Tri2ModelValidator.startValidationProcess()...gitObjectName:" + gitObjectName);
                        if(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null
                                && gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE() != null)
                        {
                            Boolean latestVersionFlagChecked = gitMappedBeanObj.getLATEST_VERSION_FLAG();
                            if(latestVersionFlagChecked != null
                                    && latestVersionFlagChecked.booleanValue()
                        //IS123764 - Map to latest version is not working in Git tab.
                                    && gitObjectName.equals(gitOldObjectName))
                            {
                                String latestVersion = gitMappedBeanObj.getMIG_DEV_OBJECT_LATEST_VERSION();
                                if(latestVersion != null)
                                {
                                	gitMappedBeanObj.setMIG_DEV_OBJECT_VERSION(latestVersion);
                                }
                            }
                            this.validateFileExtension(gitMappedBeanObj);

                            String objectType = gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
                            String copyBasePath = gitMappedBeanObj.getTEMP_BASE_PATH();
                            String objectVersionString = gitMappedBeanObj.getMIG_DEV_OBJECT_VERSION();
                            String objectDownloadSource = gitMappedBeanObj.getMIG_OBJ_DOWNLOAD_SOURCE();

                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectType(MapGIT):" + objectType);
                            System.out.println("Tri2ModelValidator.startValidationProcess()...objectDownloadSource(MapGIT):" + objectDownloadSource);

                            if(objectType != null)
                            {
                            	boolean isSQLObject = false;
                                if(isSchemaRequired(objectType))
                                {
                                    if(gitMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(gitObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' is mandatory for "+ objectType +" object.\n      Select 'Schema' for '");
                                        msg.append(gitObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;

                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Git ::: "
                                                + msg + "   FLAG : " + returnFlag);
                                    }
                                    isSQLObject = isSQLObjectType(objectType);// IS110822 - Added to make the SQL Line width validation as thread based
                                    if(isSQLObject && gitMappedBeanObj.getDATABASE_TYPE() == null && validateDatabaseType)
                                    {
                                        msg.append("\n ");
                                        msg.append(gitObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Database Type' is mandatory as workflow contains target instances with different database types.\n      Select 'Database Type' for '");
                                        msg.append(gitObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... Database Type Git ::: " +  msg  + " FLAG : " + returnFlag);
                                    }
                                }

                                if(validateExtractFile.equals("true"))
                                {
                                    System.out.println("Inside GIT, SQL file each line length validation flag is true.");
                                    String projectPathName = null;
                                    int lastSlash = gitObjectName.lastIndexOf("/");
                                    String objectPath = null;
                                    if(lastSlash != - 1)
                                    {
                                        objectPath = gitObjectName.substring(0, lastSlash);
                                        projectPathName = objectPath;
                                        gitObjectName = gitObjectName.substring(lastSlash + 1, gitObjectName.length());
                                    }
                                    HashMap beanObjectData = new HashMap();
                                    beanObjectData.put("attachedFrom", "mapGIT");
                                    beanObjectData.put("gitObjectName", gitObjectName);
                                    beanObjectData.put("gitObjectVersion", objectVersionString);
                                    beanObjectData.put("gitProjectModule", projectPathName);
                                    beanObjectData.put("gitType", objectDownloadSource);
                                    beanObjectData.put("objectType", objectType);
                                    beanObjectData.put("isSQLObject", isSQLObject); // IS110822 - Added to make the SQL Line width validation as thread based
                                    beanObjectData.put("onlinePatchingMode", onlinePatchingMode);
                                    beanObjectData.put("issueNumber", issueNumber);
                                    beanObjectData.put("beanIndex", Integer.toString(gitObjectsIndex));
                                    System.out.println("Tri2ModelValidator.startValidationProcess() beanObjectData::" + beanObjectData);
                                    if(isAOLObject(objectType))
                                    {
                                    	System.out.println(gitObjectName + " is adding for AOL Objects ");
                                    	allSQLObjectsDataMap.put("mapGIT_" + Integer.toString(gitObjectsIndex), beanObjectData);
                                    }
                                    if(isValidationRequired(objectType))
                                    {
                                        System.out.println(gitObjectName
                                                + " is adding for SQL file each line length validation. ");
                                        allSQLObjectsDataMap.put("mapGIT_" + Integer.toString(gitObjectsIndex), beanObjectData);
                                    }
                                    else if(isOnlinePatchingEnabledForTargetInstanceFlag)
                                    {
                                        System.out.println("Tri2ModelValidator.startValidationProcess()...other than SQL in Map GIT!");
                                        beanObjectData.put("editioned", editioned);
                                        allOtherObjectsExceptSQL.put("mapGIT_" + Integer.toString(gitObjectsIndex), beanObjectData);
                                    }
                                }
                               
                                if(objectType.equalsIgnoreCase("BA_FOLDER")
                                        || objectType.equalsIgnoreCase("BUSINESS_AREA")
                                        || objectType.equalsIgnoreCase("WORKBOOK"))
                                {
                                    if(gitMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'Schema' IS MANDATORY FOR DISCOVERER OBJECTS.\n      Select 'Schema' for '");
                                        msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                        msg.append("'.\n");
                                        returnFlag = false;
                                        System.out.println("Tri2ModelValidator.startValidationProcess()..... SCHEMA Git ::: "
                                                + msg + "   FLAG : " + returnFlag);
                                    }
                                    if(gitMappedBeanObj.getORA_DISC_EUL_NAME() == null)
                                    {
                                        msg.append("\n ");
                                        msg.append(gitObjectName);
                                        msg.append("\n ");
                                        msg.append("      [ERROR]: 'EUL Name' IS MANDATORY FOR OBJECTS.\n      Select 'EUL Name' for '");
                                        msg.append(gitObjectName);
                                        msg.append("'.\n");
                                        returnFlag = false;
                                    }
                                }
                                if((!objectType.equalsIgnoreCase("XML_PUB_REPORTS")) && gitMappedBeanObj.getLANGUAGE() != null)
                                {
                                	gitMappedBeanObj.setLANGUAGE(null);
                                }
                                else if(gitMappedBeanObj.getLANGUAGE() == null)
                                {
                                	gitMappedBeanObj.setLANGUAGE("en");
                                }
                            }

                            if(isObjectTypeAvailable(objectType))
                            {
                                if(gitMappedBeanObj.getMIG_DEV_OBJECT_SCHEMA() == null)
                                {
                                	gitMappedBeanObj.setMIG_DEV_OBJECT_SCHEMA("APPS");
                                }

                                if((gitMappedBeanObj.getMIG_APPL_SHORT_NAME() == null || gitMappedBeanObj.getMIG_FORM_APPLICATION_TOP() == null)
                                        && this.isApplicationTopRequired(objectType))
                                {
                                    msg.append("\n ");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    msg.append("      [ERROR]: 'Oracle Application Top' AND 'Oracle Application Short Name' ARE MANDATORY FOR AOL OBJECTS.\n      Select 'Oracle Application Top' AND 'Oracle Application Short Name' for '");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("'.\n");
                                    returnFlag = false;
                                    System.out.println("Tri2ModelValidator.startValidationProcess()..... SHORT Git ::: "
                                            + msg + "   FLAG : " + returnFlag);
                                }
                                if(objectType.equalsIgnoreCase("XML_PUB_REPORTS"))
                                {
                                	if(!(gitMappedBeanObj.getLOB_CODE() != null && ! gitMappedBeanObj.getLOB_CODE().equalsIgnoreCase(""))
                                			|| !(gitMappedBeanObj.getLOB_TYPE() != null && ! gitMappedBeanObj.getLOB_TYPE().equalsIgnoreCase(""))
                                			|| !(gitMappedBeanObj.getXDO_FILE_TYPE() != null && ! gitMappedBeanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                	{
                                		msg.append("\n ");
                                		msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("\n");
                                	}
                                	if(!(gitMappedBeanObj.getLOB_CODE() != null && ! gitMappedBeanObj.getLOB_CODE().equalsIgnoreCase("")))
                                	{
                                		msg.append("      [ERROR]: 'LOB Code' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Code' for '");
                                		msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("'.\n");
                                		returnFlag = false;
                                	}
                                	if(!(gitMappedBeanObj.getLOB_TYPE() != null && ! gitMappedBeanObj.getLOB_TYPE().equalsIgnoreCase("")))
                                	{ 
                                		msg.append("\n      [ERROR]: 'LOB Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'LOB Type' for '");
                                		msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("'.\n");
                                		returnFlag = false;
                                	}
                                	if(!(gitMappedBeanObj.getXDO_FILE_TYPE() != null && ! gitMappedBeanObj.getXDO_FILE_TYPE().equalsIgnoreCase("")))
                                	{ 
                                		msg.append("\n      [ERROR]: 'XDO File Type' IS MANDATORY FOR XML_PUB_REPORTS.\n      Please provide 'XDO File Type' for '");
                                		msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                		msg.append("'.\n");
                                		returnFlag = false;
                                	}
                                }

                                if(objectType.equalsIgnoreCase("ORACLE_WORKFLOW")
                                        && gitMappedBeanObj.getOracleWorkFlowUploadMode() == null)
                                {
                                    msg.append("\n ");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    msg.append("      [ERROR]: 'Oracle WorkFlow Upload Mode' IS MANDATORY FOR ORACLE WORKFLOW MIGRATION,SELECT MODE VALUE FORM LIST OF VALUES OF 'OracleWorkflow Upload Mode'.\n");
                                    returnFlag = false;
                                }
                            }
                            if(objectType.equalsIgnoreCase("INFOLEASE_DICTIONARY_OBJECTS"))
                            {
                                String objectName = gitMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                if(gitMappedBeanObj.getDESTINATION_DICTIONARY_FILE() == null
                                        || gitMappedBeanObj.getDICTIONARY_RECORD_IDS() == null)
                                {
                                    msg.append("\n ");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());

                                    if(gitMappedBeanObj.getDESTINATION_DICTIONARY_FILE() == null)
                                    {
                                        msg.append("\n");
                                        msg.append("\n");
                                        msg.append("      [ERROR]: Target Dictionary File Name is mandatory for object type 'INFOLEASE_DICTIONARY_OBJECTS'.\n\n      Please provide valid Target file name in 'Target Dictionary File' field. \n \n");
                                    }

                                    if(gitMappedBeanObj.getDICTIONARY_RECORD_IDS() == null)
                                    {
                                        msg.append("\n");
                                        msg.append("\n");
                                        msg.append("      [ERROR]: DictionaryRecord Id's is mandatory for object type 'INFOLEASE_DICTIONARY_OBJECTS'.\n\n      Please provide valid Dictionary Record Id's (for multiple record id's provide comma separated values ) in 'Dictionary Record Id's' field. \n\n");
                                    }
                                    returnFlag = false;
                                }
                            }

                            if(objectType.equalsIgnoreCase("COPY")
                                    || objectType.equalsIgnoreCase("COPY AND EXTRACT")
                                    || objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                    || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                    || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")
                                    || objectType.equalsIgnoreCase("SOFTLINK")
                            	
                                  //IS111135 - Migration of OAF Objects getting failed when mapped from CVS/SVN/GIT tabs
                                    
                                    || objectType.equalsIgnoreCase("OAF-COPY")
                                    || objectType.equalsIgnoreCase("OAF-WEB_UI")
                                    || objectType.equalsIgnoreCase("OAF_STANDARD-JPX")
                                    || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-COPY")
                                    || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-WEB_UI"))
                            {
                                String objectName = gitMappedBeanObj.getMIG_DEV_OBJECT_NAME();
                                if(copyBasePath == null)
                                {
                                    msg.append("\n ");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");

                                    msg.append("      [ERROR]: Target directory folder is mandatory for object type '"
                                            + objectType);

                                    if((objectType.equalsIgnoreCase("INFOLEASE_REPORTS")
                                            || objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS")
                                            || objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS")))
                                    {

                                        if(objectType.equalsIgnoreCase("INFOLEASE_PROGRAMS"))
                                        {
                                            msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'USER.DEFINED.BP' \n");
                                        }
                                        else if(objectType.equalsIgnoreCase("INFOLEASE_REPORTS"))
                                        {
                                            msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'RECALLS' \n");
                                        }
                                        else if(objectType.equalsIgnoreCase("INFOLEASE_SCRIPTS"))
                                        {
                                            msg.append( "'.\n      Provide valid target folder name in 'Target Path' field. \n      For example :: 'njs' \n");
                                        }
                                    }
                                    else
                                    {
                                        msg.append("'.\n      Provide valid path in 'Target Path' field. \n      For Reference :: '$XX_TOP/bin/..etc.' \n\n");
                                    }
                                    returnFlag = false;
                                }
                                else
                                {
                                	gitMappedBeanObj.setMIG_FORM_APPLICATION_TOP(copyBasePath);
                                }
                            }

                            if(objectType.equalsIgnoreCase("ORACLE_PATCH"))
                            {
                                if(gitMappedBeanObj.getORA_SYSTEM_PWD() == null
                                        || gitMappedBeanObj.getORACLE_PATCH_NUMBER() == null)
                                {
                                    msg.append("\n ");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    msg.append("      [ERROR]: PLEASE PROVIDE ORACLE SYSTEM USER PASSWORD AND ORACLE PATCH NUMBER.");
                                    returnFlag = false;
                                }
                            }
                            /**
                             * IS112542 - While migration of Execute shell script object type, right now the target path is not being captured in migration log though provided.
                             * */
                            if(objectType.equalsIgnoreCase("EXECUTE_SHELL SCRIPT") && gitMappedBeanObj.getTEMP_BASE_PATH() != null)
                            {
                            	gitMappedBeanObj.setMIG_FORM_APPLICATION_TOP(gitMappedBeanObj.getTEMP_BASE_PATH());
                            }
                            if(objectType.equalsIgnoreCase("IDEMPIERE_BUNDLE"))
                            {
                            	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                            			+ gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                            	if(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                            	{
                            		if(! gitMappedBeanObj.getMIG_DEV_OBJECT_NAME().toLowerCase().endsWith(".jar") )
                            		{
                            			System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                            			msg.append("\n ");
                            			msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            			msg.append("\n");
                            			msg.append("      [ERROR]: OBJECT TYPE " + objectType + " SUPPORTS ONLY '.jar' FILE.\n ");
                            			returnFlag = false;
                            		}
                            	}
                            }
                            
                            if(isIdempierePackInObject(objectType))
                            {
                            	System.out.println("Tri2ModelValidator.startValidationProcess()objectName :: "
                            			+ gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() + ", objectType:" + objectType);
                            	if(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null)
                            	{
                            		if(! gitMappedBeanObj.getMIG_DEV_OBJECT_NAME().toLowerCase().endsWith(".zip") )
                            		{
                            			System.err.println("Tri2ModelValidator.startValidationProcess() inside objectName.endsWith(.jar) :: ");
                            			msg.append("\n ");
                            			msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            			msg.append("\n");
                            			msg.append("      [ERROR]: OBJECT TYPE " + objectType + " SUPPORTS ONLY '.zip' FILE.\n ");
                            			returnFlag = false;
                            		}
                            	}
                            }

                            try
                            {
                                if(objectVersionString != null)
                                {
                                    System.out.println("Tri2ModelValidator.startValidationProcess()....objectVersionString :: "
                                            + objectVersionString);
                                }
                                else
                                {
                                    msg.append("\n ");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("\n ");
                                    msg.append("      [ERROR]:  Please enter object version number for the object [");
                                    msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                                    msg.append("]");
                                    returnFlag = false;
                                }

                            }
                            catch(NumberFormatException e)
                            {
                                System.out.println("Tri2ModelValidator.startValidationProcess().... ::: Version is not a Double Value"
                                        + e.getMessage());
                                e.printStackTrace();
                            }
                            catch(Exception e)
                            {
                                System.out.println("Tri2ModelValidator.startValidationProcess()"
                                        + e.getMessage());
                                e.printStackTrace();
                            }
                        }
                        else
                        {
                            msg.append("      [ERROR]: Please provide all required fields for '");
                            if(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME() != null && !gitMappedBeanObj.getMIG_DEV_OBJECT_NAME().equalsIgnoreCase(""))
                            {
                                msg.append(gitMappedBeanObj.getMIG_DEV_OBJECT_NAME());
                            }
                            else
                            {
                                msg.append("Map GIT objects.");
                            }
                            msg.append("'.\n\n");
                            returnFlag = false;
                        }
                        if(gitMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (gitMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                        {
                            if(!atleastOneMigrateFlagChecked)
                            {
                                atleastOneMigrateFlagChecked = true;
                            }
                        }  
                    }

//                    migrationSequence = gitMappedBeanObj.getMIG_MIGRATION_SEQUENCE();
//                    migrationSequences.add(migrationSequence);
//                   
//                    dependOn = gitMappedBeanObj.getDEPEND_ON();
//                  	dependOns.add(dependOn);
//                    System.out.println("Tri2ModelValidator.startValidationProcess()(Map GIT Objects)...migrationSequence:" + migrationSequence
//                            + ", dependOn:" + dependOn);
                }
                migrationSequence = gitMappedBeanObj.getMIG_MIGRATION_SEQUENCE();
                migrationSequences.add(migrationSequence);
               
                dependOn = gitMappedBeanObj.getDEPEND_ON();
              	dependOns.add(dependOn);
              	
              	/**
                 * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
                 */
              	
              	onSuccess = gitMappedBeanObj.getON_SUCCESS();
			    onSuccesses.add(onSuccess);
			    successMap.put(migrationSequence, onSuccess);
			    onFailure = gitMappedBeanObj.getON_FAILURE();
			    onFailures.add(onFailure);
			    failureMap.put(migrationSequence, onFailure);
                System.out.println("Tri2ModelValidator.startValidationProcess()(Map GIT Objects)...migrationSequence:" + migrationSequence
                        + ", dependOn:" + dependOn);
                System.out.println("Tri2ModelValidator.startValidationProcess()(Upload Objects)...onSuccess:" + onSuccess
                        + ", onFailure:" + onFailure);
            }
        }

        // Map Triniti Properties Tab
        /**
         * IS073785 - Need to show alert message if user doesn't provide all required values while mapping Triniti Properties.
         * author :: rsahu
         */
        SG_TRI2_MIG_PROPERTIES_OBJECTS propertyMappedObj = null;
        SG_TRI2_MIG_PROPERTIES_OBJECTS[] propertyMappedDetails = migrationRequestBean.getSG_TRI2_MIG_PROPERTIES_OBJECTS();
        if (propertyMappedDetails != null && propertyMappedDetails.length > 0) 
        {
            int lengthOfPropertyMappedBeanArr = propertyMappedDetails.length;
            for (int propBeanIndex = 0; propBeanIndex < lengthOfPropertyMappedBeanArr; propBeanIndex++) 
            {
                propertyMappedObj = propertyMappedDetails[propBeanIndex];
                if (propertyMappedObj != null) 
                {
                    if (propertyMappedObj.getMIGRATION_PROPERTY_LOCATION() != null
                            || propertyMappedObj.getMIGRATION_PROPERTY_FILE_NAME() != null
                            || propertyMappedObj.getMIGRATION_PROPERTY_KEY() != null
                            || propertyMappedObj.getMIGRATION_PROPERTY_VALUE() != null) 
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;
                        }
                        isAtleastOneObjectModified = true;
                        if (!((propertyMappedObj.getMIGRATION_PROPERTY_LOCATION() != null && !propertyMappedObj.getMIGRATION_PROPERTY_LOCATION().isEmpty())
                                && (propertyMappedObj.getMIGRATION_PROPERTY_FILE_NAME() != null && !propertyMappedObj.getMIGRATION_PROPERTY_FILE_NAME().isEmpty())
                                && (propertyMappedObj.getMIGRATION_PROPERTY_KEY() != null && !propertyMappedObj.getMIGRATION_PROPERTY_KEY().isEmpty())
                                && (propertyMappedObj.getMIGRATION_PROPERTY_VALUE() != null && !propertyMappedObj.getMIGRATION_PROPERTY_VALUE().isEmpty()))) 
                        {
                            msg.append("      [ERROR]: Please provide all required fields for Properties.\n Property File Directory, Property File Name,\n Property Key, Property Value are mandatory!\n\n");
                            returnFlag = false;
                        } 
                    }
                }
                /*
                 * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                 */
                if(propertyMappedObj.getMIGRATION_FLAG() != null && (propertyMappedObj.getMIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }  
            }
        }
        //IS109796 - During object mapping, only modified objects should get saved (Right now all objects are getting saved)
        /**
         * @author ashnarani.barik
         */
        //Map Predecessor Issues Tab
        SG_TRI2_PREDECESSOR_ISSUE predecessorMappedObj = null;
        SG_TRI2_PREDECESSOR_ISSUE[] predecessorMappedDetails = migrationRequestBean.getSG_TRI2_PREDECESSOR_ISSUE();
        if(predecessorMappedDetails != null && predecessorMappedDetails.length > 0) 
        {
        	int lengthOfPredecessorMappedBeanArr = predecessorMappedDetails.length;
            for (int predBeanIndex = 0; predBeanIndex < lengthOfPredecessorMappedBeanArr; predBeanIndex++) 
            {
                predecessorMappedObj = predecessorMappedDetails[predBeanIndex];
                if (predecessorMappedObj != null) 
                {
                	//IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                	solutionObjectIdList.add(predecessorMappedObj.getIssueNumber());
                    if (predecessorMappedObj.getIssueNumber() != null
                            || predecessorMappedObj.getIssueTitle() != null) 
                    { 
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;
                        }
                      //IS109796 - During object mapping, only modified objects should get saved (Right now all objects are getting saved)
                        isAtleastOneObjectModified = true;
                        if(!((predecessorMappedObj.getIssueNumber() != null && !predecessorMappedObj.getIssueNumber().isEmpty())
                                && (predecessorMappedObj.getIssueTitle() != null && !predecessorMappedObj.getIssueTitle().isEmpty())))
                        {
                        	 msg.append("      [ERROR]: Please provide all required fields.");
                             returnFlag = false;
                        	
                        }
                    } 
                    
                } 
            }   
        }
        /*
         * IS083433 - Provision to map DB objects from source instance 
         * (which will be checked-in to configured path in repository) and
         *  migrate to required target instance
         */
        // Map SQL Objects Tab
        SG_TRI2_MIG_SQL_EXPORT  mapSqlObject = null;
        if(returnFlag && mapSqlObjectsArray != null && lengthOfMapSqlObjBeanArray > 0)
        {
        	//IS115065 - Implement Object locking feature in AOM while mapping the objects from source environment.
        	System.out.println("Tri2ModelValidator.startValidationProcess() Map SQL Object");
            for (int mapSqlObjectsIndex = 0; mapSqlObjectsIndex < lengthOfMapSqlObjBeanArray; mapSqlObjectsIndex ++) 
            {
                mapSqlObject = mapSqlObjectsArray[mapSqlObjectsIndex];
                if(mapSqlObject != null) 
                {
                	//IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                	solutionObjectIdList.add(mapSqlObject.getSQL_EXPORT_ISSUE_SOLUTION_OBJECT_ID());
                    if((mapSqlObject.getSQL_EXPORT_INSTANCE_SCHEMA_NAME() != null && !mapSqlObject.getSQL_EXPORT_INSTANCE_SCHEMA_NAME().equalsIgnoreCase(""))
                            || (mapSqlObject.getSQL_EXPORT_SQL_TYPE() != null && !mapSqlObject.getSQL_EXPORT_SQL_TYPE().equalsIgnoreCase(""))
                            || mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME() != null && !mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME().equalsIgnoreCase(""))
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;                        
                        }
                        isAtleastOneObjectModified = true;
                        if(!((mapSqlObject.getSQL_EXPORT_INSTANCE_SCHEMA_NAME() != null && !mapSqlObject.getSQL_EXPORT_INSTANCE_SCHEMA_NAME().equalsIgnoreCase(""))
                                && (mapSqlObject.getSQL_EXPORT_SQL_TYPE() != null && !mapSqlObject.getSQL_EXPORT_SQL_TYPE().equalsIgnoreCase(""))
                                && mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME() != null && !mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME().equalsIgnoreCase(""))
                                )   
                        {
                            msg.append("      [ERROR]: Please provide all required fields for '");
                            if(mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME() != null && !mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME().equalsIgnoreCase(""))
                            {
                                msg.append(mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME());
                            }
                            else
                            {
                                msg.append("Map SQL objects.");
                            }
                            msg.append("'\n Source Instance, Schema Name, SQL Type, Object Name are mandatory for Map SQL objects!\n\n");
                            returnFlag = false;
                        }
                        //IS115065 - Implement Object locking feature in AOM while mapping the objects from source environment.
                        else
                        {
                        	System.out.println("Tri2ModelValidator.startValidationProcess() else block ObjectName : " +
                        			mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME() + "ObjectType : " + mapSqlObject.getSQL_EXPORT_SQL_TYPE());
                        	String objectName = mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME();
                        	String objectType = mapSqlObject.getSQL_EXPORT_SQL_TYPE();
                        	String lockObject = TRI2Utils.getTRI2PropertyValue("lockObject");
                        	System.out.println("Tri2ModelValidator.startValidationProcess() lockObject : " + lockObject);
                        	 if("true".equalsIgnoreCase(lockObject) && checkObjectIsLocakedOrNot(objectName,objectType,"Y"))
                             {
                        		 System.out.println("Tri2ModelValidator.startValidationProcess() else block ObjectName : " +
                        				 mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME()  + "is Locked");
                                 msg.append("Map SQL objects [" + mapSqlObject.getSQL_EXPORT_SQL_OBJECT_NAME() + "] is Locked.");
                                 returnFlag = false;
                             }                        	
                        }
                    }
                    /*else
                    {
                        msg.append("      [ERROR]: Source Instance  is mandatory for Map SQL Obejcts.\n");
                        returnFlag = false;
                    }*/
                }
                /*
                 * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                 */
                if(mapSqlObject.getSQL_EXPORT_MIG_MIGRATION_FLAG() != null && (mapSqlObject.getSQL_EXPORT_MIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }  
            }   
        }
        /*
         *IS083721:Option to map discoverer objects from source instance,
         *check-in to repository in a configured path and migrate to 
         *required target instance.
         */
        SG_TRI2_ORA_DISC_EXPORT  mapOraDiscObject = null;
        if(returnFlag && mapOraDiscObjectsArray != null && lengthOfOraDiscObjBeanArray > 0)
        {
            for (int mapOraDiscObjectsIndex = 0; mapOraDiscObjectsIndex < lengthOfOraDiscObjBeanArray; mapOraDiscObjectsIndex ++) 
            {
                mapOraDiscObject = mapOraDiscObjectsArray[mapOraDiscObjectsIndex];
                if(mapOraDiscObject != null) 
                {
                	//IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                    solutionObjectIdList.add(mapOraDiscObject.getORA_DISC_ISSUE_SOLUTION_OBJECT_ID());
                    if((mapOraDiscObject.getORA_DISC_SOURCE_INSTANCE_NAME() != null && !mapOraDiscObject.getORA_DISC_SOURCE_INSTANCE_NAME().equalsIgnoreCase(""))
                            || (mapOraDiscObject.getORA_DISC_SOURCE_SCHEMA() != null && !mapOraDiscObject.getORA_DISC_SOURCE_SCHEMA().equalsIgnoreCase(""))
                            || (mapOraDiscObject.getORA_DISC_EUL_NAME() != null && !mapOraDiscObject.getORA_DISC_EUL_NAME().equalsIgnoreCase(""))
                            || (mapOraDiscObject.getORA_DISC_OBJECT_TYPE() != null && !mapOraDiscObject.getORA_DISC_OBJECT_TYPE().equalsIgnoreCase(""))
                            || (mapOraDiscObject.getORA_DISC_OBJECT_NAME() != null && !mapOraDiscObject.getORA_DISC_OBJECT_NAME().equalsIgnoreCase(""))
                            || (mapOraDiscObject.getORA_DISC_OBJECT_KEY() != null && !mapOraDiscObject.getORA_DISC_OBJECT_KEY().equalsIgnoreCase("")))
                    {
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;                        
                        }
                        isAtleastOneObjectModified = true;
                        if(!((mapOraDiscObject.getORA_DISC_SOURCE_INSTANCE_NAME() != null && !mapOraDiscObject.getORA_DISC_SOURCE_INSTANCE_NAME().equalsIgnoreCase(""))
                                && (mapOraDiscObject.getORA_DISC_SOURCE_SCHEMA() != null && !mapOraDiscObject.getORA_DISC_SOURCE_SCHEMA().equalsIgnoreCase(""))
                                && (mapOraDiscObject.getORA_DISC_EUL_NAME() != null && !mapOraDiscObject.getORA_DISC_EUL_NAME().equalsIgnoreCase(""))
                                && (mapOraDiscObject.getORA_DISC_OBJECT_TYPE() != null && !mapOraDiscObject.getORA_DISC_OBJECT_TYPE().equalsIgnoreCase(""))
                                && (mapOraDiscObject.getORA_DISC_OBJECT_NAME() != null && !mapOraDiscObject.getORA_DISC_OBJECT_NAME().equalsIgnoreCase(""))
                                && (mapOraDiscObject.getORA_DISC_OBJECT_KEY() != null && !mapOraDiscObject.getORA_DISC_OBJECT_KEY().equalsIgnoreCase("")))
                            )
                        {
                            msg.append("      [ERROR]: Please provide all required fields for '");
                            if(mapOraDiscObject.getORA_DISC_OBJECT_NAME() != null && !mapOraDiscObject.getORA_DISC_OBJECT_NAME().equalsIgnoreCase(""))
                            {
                                msg.append(mapOraDiscObject.getORA_DISC_OBJECT_NAME());
                            }
                            else
                            {
                                msg.append("Map Discoverer objects.");
                            }
                            msg.append("'\n Source Instance, Schema, End User Layer, Object Type, Object Identifier, Object Name are mandatory for Map Discoverer objects!\n\n");
                            returnFlag = false;
                        }
                    }
                }
                /*
                 * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                 */
                if(mapOraDiscObject.getORA_DISC_MIGRATION_FLAG() != null && (mapOraDiscObject.getORA_DISC_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                }
            }   
        }
        /**
         * IS083081 - Option to map AOL objects from source instance, check-in to repository in a configured path and migrate to required target instance
         */
        //Map AOL Objects
        SG_TRI2_MIG_AOL_OBJECTS mapAOLObject = null;
        System.out.println("Tri2ModelValidator.startValidationProcess()...returnFlag:" + returnFlag + ", lengthOfMapAOLObjectsBeanArray:" + lengthOfMapAOLObjectsBeanArray);
        if (returnFlag && mapAOLObjectsArray != null && lengthOfMapAOLObjectsBeanArray > 0) 
        {
        	System.out.println("Tri2ModelValidator.startValidationProcess() Map AOL Object");
            for (int mapAOLObjectsIndex = 0; mapAOLObjectsIndex < lengthOfMapAOLObjectsBeanArray; mapAOLObjectsIndex ++) 
            {
                mapAOLObject = mapAOLObjectsArray[mapAOLObjectsIndex];
                if (mapAOLObject != null) 
                {
                	//IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
                    solutionObjectIdList.add(mapAOLObject.getAolIssue_Solution_Object_Id());
                    if((mapAOLObject.getSourceInstanceName() != null && !mapAOLObject.getSourceInstanceName().equalsIgnoreCase(""))
                            || (mapAOLObject.getApplicationName() != null && !mapAOLObject.getApplicationName().equalsIgnoreCase(""))
                            || (mapAOLObject.getApplicationShortName() != null && !mapAOLObject.getApplicationShortName().equalsIgnoreCase(""))
                            || (mapAOLObject.getApplicationBasePath() != null && !mapAOLObject.getApplicationBasePath().equalsIgnoreCase(""))
                            || (mapAOLObject.getEntityName() != null && !mapAOLObject.getEntityName().equalsIgnoreCase(""))
                            || (mapAOLObject.getObjectType() != null && !mapAOLObject.getObjectType().equalsIgnoreCase(""))
                            || (mapAOLObject.getObjectName() != null && !mapAOLObject.getObjectName().equalsIgnoreCase("")))
                    {
                        System.out.println("Tri2ModelValidator.startValidationProcess()...mapAOLObject.getObjectName():" + mapAOLObject.getObjectName()
                        + "Lock Object : " + mapAOLObject.getLOCK_OBJECT());
                        if(!isSolutionObjectAttached)
                        {
                            isSolutionObjectAttached = true;                        
                        }
                        isAtleastOneObjectModified = true;
                        if(!((mapAOLObject.getSourceInstanceName() != null && !mapAOLObject.getSourceInstanceName().equalsIgnoreCase(""))
                                && (mapAOLObject.getApplicationName() != null && !mapAOLObject.getApplicationName().equalsIgnoreCase(""))
                                && (mapAOLObject.getApplicationShortName() != null && !mapAOLObject.getApplicationShortName().equalsIgnoreCase(""))
                                && (mapAOLObject.getApplicationBasePath() != null && !mapAOLObject.getApplicationBasePath().equalsIgnoreCase(""))
                                && (mapAOLObject.getEntityName() != null && !mapAOLObject.getEntityName().equalsIgnoreCase(""))
                                && (mapAOLObject.getObjectType() != null && !mapAOLObject.getObjectType().equalsIgnoreCase(""))
                                && (mapAOLObject.getObjectName() != null && !mapAOLObject.getObjectName().equalsIgnoreCase("")))
                                )
                        {
                            msg.append("      [ERROR]: Please provide all required fields for '");
                            if(mapAOLObject.getObjectName() != null && !mapAOLObject.getObjectName().equalsIgnoreCase(""))
                            {
                                msg.append(mapAOLObject.getObjectName());
                            }
                            else
                            {
                                msg.append("Map AOL objects.");
                            }
                            msg.append("'\n Source Instance, Application Name, Oracle Apps Short name, Oracle Apps Top, Entity Name, Object Type are mandatory for Map AOL objects!\n\n");
                            returnFlag = false;
                        }
                        //IS115065 - Implement Object locking feature in AOM while mapping the objects from source environment.
                        else
                        {
                        	System.out.println("Tri2ModelValidator.startValidationProcess() else block ObjectName : " +
                        			mapAOLObject.getObjectName() + "ObjectType : " + mapAOLObject.getObjectType());
                        	String objectName = mapAOLObject.getObjectName();
                        	String objectType = mapAOLObject.getObjectType();
                        	String lockObject = TRI2Utils.getTRI2PropertyValue("lockObject");
                        	System.out.println("Tri2ModelValidator.startValidationProcess() lockObject : " + lockObject);
                        	 if( lockObject != null && lockObject.equalsIgnoreCase("true") && checkObjectIsLocakedOrNot(objectName,objectType,"Y"))
                             {
                        		 System.out.println("Tri2ModelValidator.startValidationProcess() else block ObjectName : " +
                             			mapAOLObject.getObjectName()  + "is Locked");
                                 msg.append("Mapped object [" + mapAOLObject.getObjectName() + "] is already Locked.");
                                 returnFlag = false;
                             }                        	
                        }
                    }
                    /*else
                    {
                        msg.append("      [ERROR]: Source Instance is mandatory for the object in Map AOL objects.\n");
                        returnFlag = false;
                    }*/      
                }
                /*
                 * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                 */
                if(mapAOLObject.getAOL_MIG_MIGRATION_FLAG() != null && (mapAOLObject.getAOL_MIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
                {
                    if(!atleastOneMigrateFlagChecked)
                    {
                        atleastOneMigrateFlagChecked = true;
                    }
                } 
            }
        }

      //Map Informatica Objects
        SG_TRI2_MIG_INFORMATICA_OBJECTS mapInformaticaObject = null;
        System.out.println("Tri2ModelValidator.startValidationProcess()...returnFlag:" + returnFlag + ", lengthOfmapInformaticaObjectsArray:" + lengthOfmapInformaticaObjectsArray);
        if (returnFlag && mapInformaticaObjectsArray != null && lengthOfmapInformaticaObjectsArray > 0) 
        {
            for (int mapInformaticaObjectIndex = 0; mapInformaticaObjectIndex < lengthOfmapInformaticaObjectsArray; mapInformaticaObjectIndex ++) 
            {
            	mapInformaticaObject = mapInformaticaObjectsArray[mapInformaticaObjectIndex];
            	
            	StringBuffer fieldsRequired = new StringBuffer();
            	
            	fieldsRequired = checkMissingForInformatica(mapInformaticaObject);
            	
            	if("".equals(fieldsRequired.toString()))
                {
            		String informaticaObjectType = mapInformaticaObject.getobjectType();
            		
            		if("Informatica Workflow".equalsIgnoreCase(informaticaObjectType))
            		{
            			if(!isEmpty(mapInformaticaObject.getsourceWorkFlow()))
            			{
            				returnFlag = true;
                            isSolutionObjectAttached = true;
                            atleastOneMigrateFlagChecked = true;
            			}
            			else
            			{
            				returnFlag = false;
            				msg.append("Source Workflow is required for Object Type Informatica Workflow!");
            				break;
            			}
            		}
            		else if("Informatica Mapping".equalsIgnoreCase(informaticaObjectType))
            		{
            			if(!isEmpty(mapInformaticaObject.getsourceMapping()))
            			{
            				returnFlag = true;
                            isSolutionObjectAttached = true;  
                            atleastOneMigrateFlagChecked = true;
            			}
            			else
            			{
            				returnFlag = false;
            				msg.append("Source Mapping is required for Object Type Informatica Mapping!");
            				break;
            			}
            		}
            		else
            		{
            			returnFlag = true;
                        isSolutionObjectAttached = true; 
                        atleastOneMigrateFlagChecked = true;
            		}
            		
                }
            	else
            	{
            		returnFlag = false;
            		msg.append(fieldsRequired + " are required for Informatica Objects!");
            		break;
            	}
            }
        }
        
      //Map ics Objects
        SG_TRI2_MIG_ICS_OBJECTS mapicsObject = null;
        System.out.println("Tri2ModelValidator.startValidationProcess()...returnFlag:" + returnFlag + ", lengthOfmapicsObjectsArray:" + lengthOfmapICSObjectsArray);
        if (returnFlag && mapICSObjectsArray != null && lengthOfmapICSObjectsArray > 0) 
        {
            for (int mapicsObjectIndex = 0; mapicsObjectIndex < lengthOfmapICSObjectsArray; mapicsObjectIndex ++) 
            {
            	mapicsObject = mapICSObjectsArray[mapicsObjectIndex];
            	
    			if(isEmpty(mapicsObject.getSourceInstance()) || isEmpty(mapicsObject.getobjectName()) || isEmpty(mapicsObject.getobjectType()))
    			{
    				msg.append("All of Source Instance, Object Type and Object Name are required for ICS Objects!");
    				
    				returnFlag = false;
    			}
    			else
    			{
    				returnFlag = true;
                    isSolutionObjectAttached = true; 
                    atleastOneMigrateFlagChecked = true;
                    isAtleastOneObjectModified = true;
    			}
            }
        }
        
        System.out.println("Tri2ModelValidator.startValidationProcess()...returnFlag:" + returnFlag 
                + ", allSQLObjectsDataMap:" + allSQLObjectsDataMap + ", allOtherObjectsExceptSQL:" + allOtherObjectsExceptSQL);
        
        /***
         * IS114427 - AOM to support multiple Oracle cloud setup objects mapping with in a single migration request.
         * To Map the Cloud Setup Objects
         */
        if(mapCloudSetupObjectsArray != null && lengthOfMapCloudSetupObjectsArray > 0)
        {
        	System.out.println("Tri2ModelValidator.startValidationProcess()...going to cloudSetupMappedBeanObj  ");
        	//IS115457 - Same task code should not be allowed to map with in the same ticket for Oracle cloud setup objects.
        	Set<String> setToCheckDuplicates = new HashSet<String>();
            for(int cloudSetupObjectsIndex = 0; cloudSetupObjectsIndex < lengthOfMapCloudSetupObjectsArray; cloudSetupObjectsIndex ++ )
            {
            	cloudSetupMappedBeanObj = mapCloudSetupObjectsArray[cloudSetupObjectsIndex];
            	if(cloudSetupMappedBeanObj != null)
            	{
            		solutionObjectIdList.add(cloudSetupMappedBeanObj.getMIG_DEV_ISSUE_SOLUTION_OBJECT_ID());
            	}
            	isObjectAvailable = true;

            	if(!isSolutionObjectAttached)
            	{
            		isSolutionObjectAttached = true;
            	}
            	if(cloudSetupMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (cloudSetupMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
            	{

            		if(!atleastOneMigrateFlagChecked)
            		{
            			atleastOneMigrateFlagChecked = true;
            		}
            	}
            	/**
            	 * IS114767 - While flushing the details from Map Oracle Setup Objects tab, Task Code should be validated.
            	 */

            	if(cloudSetupMappedBeanObj != null)
            	{
            		System.out.println("Tri2ModelValidator.startValidationProcess()....cloudSetupMappedBeanObj [ " + cloudSetupObjectsIndex + " ] :" + cloudSetupMappedBeanObj);
            		isAtleastOneObjectModified = true;
            		if(!isSolutionObjectAttached)
            		{
            			isSolutionObjectAttached = true;
            		}
            		if(cloudSetupMappedBeanObj.getCONFIG_PACKAGE_NAME() != null && cloudSetupMappedBeanObj.getTASK_CODE() != null)
            		{
            			if(cloudSetupMappedBeanObj.getMIG_MIGRATION_FLAG() != null && (cloudSetupMappedBeanObj.getMIG_MIGRATION_FLAG().toString().equalsIgnoreCase("true")))
            			{
            				if(!atleastOneMigrateFlagChecked)
            				{
            					atleastOneMigrateFlagChecked = true;
            				}
            			}
            			//IS115457 - Same task code should not be allowed to map with in the same ticket for Oracle cloud setup objects.
            			System.out.println("Tri2ModelValidator.startValidationProcess() TASK_CODE  : " + cloudSetupMappedBeanObj.getTASK_CODE());
            			if(setToCheckDuplicates.contains(cloudSetupMappedBeanObj.getTASK_CODE()))  
                    	{
            				System.out.println(" Duplicate Task Code are not allowed. ");
            				if(msg.indexOf(" Duplicate Task Code") == -1)
            				{
            					msg.append(" Duplicate Task Code  \n");
            				}
            				if(!(""+msg).contains("[ " +cloudSetupMappedBeanObj.getTASK_CODE() + " ] \n"))
            				{
            					msg.append("[ " +cloudSetupMappedBeanObj.getTASK_CODE() + " ] \n");
            				}
            				returnFlag = false;
                    	}
                    	setToCheckDuplicates.add(cloudSetupMappedBeanObj.getTASK_CODE());
                    	System.out.println("Tri2ModelValidator.startValidationProcess() setToCheckDuplicates : " + setToCheckDuplicates);
            		}
            		else
            		{
            			msg.append("     [ERROR]: Please provide Config Package Name and Task Code.");
            			returnFlag = false;
            		}
            		System.out.println("Tri2ModelValidator.startValidationProcess()....cloudSetupMappedBeanObj [ " + cloudSetupObjectsIndex + " ] :" + cloudSetupMappedBeanObj);

            	}
            }
            //IS115457 - Same task code should not be allowed to map with in the same ticket for Oracle cloud setup objects.
            if(msg.indexOf("Duplicate Task Code") != -1)
            {
            	msg.append(" are not allowed.");
            }
            
        }
        
        
        
        /**
         * IS079556-Need to parse each mapped object to a ticket, validate 
         * and store status of each object against Database Compliance Checker Report(DBCC) of target instance
         */
        boolean isEditionObjectExists = false;
        boolean atleastOneOnlinePatchModeExists = false;
        StringBuilder allEditionedObjects = new StringBuilder();
        
        if(returnFlag && allSQLObjectsDataMap.size() > 0)
        {
            /**
             * IS079556-Need to parse each mapped object to a ticket, validate 
             * and store status of each object against Database Compliance Checker Report(DBCC) of target instance
             * Storing sourceInstanceName and all SQL objects details to validate
             */
            LinkedHashMap inputDataMap = new LinkedHashMap();
            
            inputDataMap.put("sourceInstanceName", sourceInstanceName);
            inputDataMap.put("allSQLObjectsDataMap", allSQLObjectsDataMap);
            
            /**
             * IS081768 - Provide an option to re-execute database compliance checker 
             * and re-validate the migration objects on demand(while approving ticket to proceed for migration)
             */
            LinkedHashMap outputDataMapFromServlet = null;
            LinkedHashMap allSQLObjectsOutputDataMap = null;
            LinkedHashMap topNameAndShortNameForAOLObject = null;
            
            String dbccLogFilePath = null;
            String dbccExecutionDate = null;
            
            HashMap eachObjValidationMap = null;
            HashMap eachObjData = null;
            Exception exception = null;
            String uniqueObjectIdentifier = null;
            Set objectNamesSet = null;
            Iterator objectNameIterator = null;
            try
            {
                System.out.println("Tri2ModelValidator.startValidationProcess()...inputDataMap:" + inputDataMap);
                outputDataMapFromServlet = getTheAttachedFileAndValidate(inputDataMap, applicationPropsURL);
                System.out.println("Tri2ModelValidator.startValidationProcess()...outputDataMapFromServlet:" + outputDataMapFromServlet);
                if(outputDataMapFromServlet != null && outputDataMapFromServlet.size() > 0)
                {
                	topNameAndShortNameForAOLObject = (LinkedHashMap) outputDataMapFromServlet.get("topNameAndShortNameForAOLObject");
                    allSQLObjectsOutputDataMap = (LinkedHashMap) outputDataMapFromServlet.get("allSQLObjectsOutputDataMap");
                    dbccLogFilePath            = (String) outputDataMapFromServlet.get("dbccLogFilePath");
                    dbccExecutionDate          = (String) outputDataMapFromServlet.get("dbccExecutionDate");
                }
                
                if(allSQLObjectsOutputDataMap != null
                        && allSQLObjectsOutputDataMap.size() > 0)
                {
                    objectNamesSet      = allSQLObjectsOutputDataMap.keySet();
                    objectNameIterator  = objectNamesSet.iterator();

                    while(objectNameIterator.hasNext())
                    {
                        uniqueObjectIdentifier = (String) objectNameIterator.next();
                        eachObjData = (HashMap) allSQLObjectsOutputDataMap.get(uniqueObjectIdentifier);
                        System.out.println("Tri2ModelValidator.startValidationProcess()...uniqueObjectIdentifier for fetching oracle short name and top name :  " + uniqueObjectIdentifier);
                        if(topNameAndShortNameForAOLObject != null && topNameAndShortNameForAOLObject.containsKey(uniqueObjectIdentifier))
                        {
                        	 String beanIndex = (String) eachObjData.get("beanIndex");
                        	// ObjectTypeConfigurationThreads Objthread =(ObjectTypeConfigurationThreads)topNameAndShortNameForAOLObject.get(uniqueObjectIdentifier);
                        	 HashMap shortNameTopName = (HashMap)topNameAndShortNameForAOLObject.get(uniqueObjectIdentifier);
                        	 SG_TRI2_CVS_MAPPED_OBJECTS mapCVSObjectBean = cvsMappedMigDetails[Integer.parseInt(beanIndex)];
                        	 
								
                        	 String shortName =(String) shortNameTopName.get("shortName");
							 String topName = (String)shortNameTopName.get("topName");
                        	 System.out.println("Tri2ModelValidator.startValidationProcess()..shortName:- "+shortName+"  topName :- " +topName);

							 mapCVSObjectBean.setMIG_APPL_SHORT_NAME(shortName);
							 mapCVSObjectBean.setMIG_FORM_APPLICATION_TOP(topName);
                        	 
                        }
                    }
                    objectNameIterator = null;
                    
                    
                }
                
                System.out.println("Tri2ModelValidator.startValidationProcess()...allSQLObjectsOutputDataMap:" + allSQLObjectsOutputDataMap
                        + ", dbccLogFilePath:" + dbccLogFilePath + ", dbccExecutionDate:" + dbccExecutionDate);
                if(dbccLogFilePath != null && !dbccLogFilePath.equalsIgnoreCase(""))
                {
                    migrationRequestBean.setDbccLogFilePath(dbccLogFilePath);
                }
                if(dbccExecutionDate != null && !dbccExecutionDate.equalsIgnoreCase(""))
                {
                    migrationRequestBean.setDbccExecutionDate(dbccExecutionDate);
                }
                if(allSQLObjectsOutputDataMap != null
                        && allSQLObjectsOutputDataMap.size() > 0)
                {
                    objectNamesSet      = allSQLObjectsOutputDataMap.keySet();
                    objectNameIterator  = objectNamesSet.iterator();

                    while(objectNameIterator.hasNext())
                    {
                        uniqueObjectIdentifier = (String) objectNameIterator.next();
                        System.out.println("Tri2ModelValidator.startValidationProcess()...uniqueObjectIdentifier:" + uniqueObjectIdentifier);
                        if(uniqueObjectIdentifier != null)
                        {
                            eachObjValidationMap = (HashMap) allSQLObjectsOutputDataMap.get(uniqueObjectIdentifier);
                            System.out.println("Tri2ModelValidator.startValidationProcess()...eachObjValidationMap:"
                                    + eachObjValidationMap);
                            if(eachObjValidationMap != null)
                            {
                                Boolean validationFlag = (Boolean) eachObjValidationMap.get("validationFlag");
                                String extractionMessage = (String) eachObjValidationMap.get("extractionMessage");
                                exception = (Exception) eachObjValidationMap.get("generatedExceptionObject");
                                System.out.println("Tri2ModelValidator.startValidationProcess()...validationFlag:" + validationFlag);

                                if(validationFlag != null && ! validationFlag.booleanValue())
                                {
                                    if(extractionMessage != null && !extractionMessage.isEmpty())
                                    {
                                        msg.append(extractionMessage);
                                    }

                                    if(exception != null)
                                    {
                                        exception.printStackTrace();
                                    }
                                    returnFlag = false;
                                }
                                if(isOnlinePatchingEnabledForTargetInstanceFlag)
                                {
                                    if(validationFlag != null && validationFlag.booleanValue())
                                    {
                                        /**
                                         * IS079556-Need to parse each mapped object to a ticket, validate and 
                                         * store status of each object against Database Compliance Checker Report(DBCC) of target instance
                                         * Checking DBCC voilation flag and setting DBCC violated objects list to bean to store into TRI2 database
                                         */
                                        String editionedObjects    = (String) eachObjValidationMap.get("editionedObjects");
                                        String dbccViolationFlag   = (String) eachObjValidationMap.get("dbccViolationFlag");
                                        String dbccViolatedObjects = (String) eachObjValidationMap.get("dbccViolatedObjects");
                                        String attachedFrom        = (String) eachObjValidationMap.get("attachedFrom");
                                        String beanIndex           = (String) eachObjValidationMap.get("beanIndex");
                                        String onlinePatchingMode  = (String) eachObjValidationMap.get("onlinePatchingMode");
                                        boolean onlinePatchingModeFlag = false;
                                        if(onlinePatchingMode != null && !onlinePatchingMode.trim().equalsIgnoreCase(""))
                                        {
                                            onlinePatchingModeFlag = Boolean.valueOf(onlinePatchingMode);
                                        }
                                        if(onlinePatchingModeFlag && !atleastOneOnlinePatchModeExists)
                                        {
                                            atleastOneOnlinePatchModeExists = true;
                                        }
                                        if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                                && attachedFrom.equalsIgnoreCase("uploadObj"))
                                        {
                                            SG_TRI2_MIGRATION_DETAILS uploadObjectBean = migDetails[Integer.parseInt(beanIndex)];
                                            if(editionedObjects != null && !editionedObjects.trim().equalsIgnoreCase(""))
                                            {
                                                if(!isEditionObjectExists)
                                                {
                                                    isEditionObjectExists = true;
                                                }
                                                if(!onlinePatchingModeFlag)
                                                {
                                                    if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                                    {
                                                        allEditionedObjects.append(uploadObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                    else
                                                    {
                                                        allEditionedObjects.append(", ");
                                                        allEditionedObjects.append(uploadObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                }
                                                else
                                                {
                                                    uploadObjectBean.setDBCC_VIOLATION_FLAG(Boolean.valueOf(dbccViolationFlag));
                                                    uploadObjectBean.setDBCC_VIOLATION_OBJECTS_LIST(dbccViolatedObjects);    
                                                }
                                            }
                                        }
                                        else if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                                && attachedFrom.equalsIgnoreCase("mapCVS"))
                                        {
                                            SG_TRI2_CVS_MAPPED_OBJECTS mapCVSObjectBean = cvsMappedMigDetails[Integer.parseInt(beanIndex)];
                                            System.out.println("Tri2ModelValidator.startValidationProcess()..mapCVSObjectBean = "+mapCVSObjectBean);
                                            if(editionedObjects != null && !editionedObjects.trim().equalsIgnoreCase(""))
                                            {
                                                if(!isEditionObjectExists)
                                                {
                                                    isEditionObjectExists = true;
                                                }
                                                if(!onlinePatchingModeFlag)
                                                {
                                                    if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                                    {
                                                        allEditionedObjects.append(mapCVSObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                    else
                                                    {
                                                        allEditionedObjects.append(", ");
                                                        allEditionedObjects.append(mapCVSObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                }
                                                else
                                                {
                                                    mapCVSObjectBean.setDBCC_VIOLATION_FLAG(Boolean.valueOf(dbccViolationFlag));
                                                    mapCVSObjectBean.setDBCC_VIOLATION_OBJECTS_LIST(dbccViolatedObjects);
                                                }
                                            }
                                        }
                                        else if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                                && attachedFrom.equalsIgnoreCase("mapSVN"))
                                        {
                                            SG_TRI2_SVN_MAPPED_OBJECTS mapSVNObjectBean = svnMappedMigDetails[Integer.parseInt(beanIndex)];
                                            if(editionedObjects != null && !editionedObjects.trim().equalsIgnoreCase(""))
                                            {
                                                if(!isEditionObjectExists)
                                                {
                                                    isEditionObjectExists = true;
                                                }
                                                if(!onlinePatchingModeFlag)
                                                {
                                                    if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                                    {
                                                        allEditionedObjects.append(mapSVNObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                    else
                                                    {
                                                        allEditionedObjects.append(", ");
                                                        allEditionedObjects.append(mapSVNObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                }
                                                else
                                                {
                                                    mapSVNObjectBean.setDBCC_VIOLATION_FLAG(Boolean.valueOf(dbccViolationFlag));
                                                    mapSVNObjectBean.setDBCC_VIOLATION_OBJECTS_LIST(dbccViolatedObjects);
                                                }
                                            }
                                        }
                                        /*
                                         * IS095667 - Integration of AOM with GIT version control system(Right
                                         * now AOM supports objects mapped from CVS and SVN)
                                         */
                                        else if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                                && attachedFrom.equalsIgnoreCase("mapGIT"))
                                        {
                                            SG_TRI2_GIT_MAPPED_OBJECTS mapGITObjectBean = gitMappedMigDetails[Integer.parseInt(beanIndex)];
                                            if(editionedObjects != null && !editionedObjects.trim().equalsIgnoreCase(""))
                                            {
                                                if(!isEditionObjectExists)
                                                {
                                                    isEditionObjectExists = true;
                                                }
                                                if(!onlinePatchingModeFlag)
                                                {
                                                    if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                                    {
                                                        allEditionedObjects.append(mapGITObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                    else
                                                    {
                                                        allEditionedObjects.append(", ");
                                                        allEditionedObjects.append(mapGITObjectBean.getMIG_DEV_OBJECT_NAME());
                                                    }
                                                }
                                                else
                                                {
                                                	mapGITObjectBean.setDBCC_VIOLATION_FLAG(Boolean.valueOf(dbccViolationFlag));
                                                	mapGITObjectBean.setDBCC_VIOLATION_OBJECTS_LIST(dbccViolatedObjects);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch(Exception exp)
            {
                exp.printStackTrace();
            }
            finally
            {
                allSQLObjectsDataMap = null;
                exception = null;
                allSQLObjectsOutputDataMap = null;
                eachObjValidationMap = null;
                objectNamesSet = null;
                objectNameIterator = null;
                uniqueObjectIdentifier = null;
            }
        }
        /**
         * IS080795 Validation of Oracle objects in TRI2 Migration Tool based on editioned/non-editioned 
         * if Target instance is configured for Online Patching migrations
         */
        if(returnFlag && isOnlinePatchingEnabledForTargetInstanceFlag && allOtherObjectsExceptSQL.size() > 0)
        {
            HashMap eachObjectMap = null;
            String uniqueObjectIdentifier = null;
            Set objectsSet = null;
            Iterator objectsIterator = null;
            try
            {
                objectsSet      = allOtherObjectsExceptSQL.keySet();
                objectsIterator  = objectsSet.iterator();

                while(objectsIterator.hasNext())
                {
                    uniqueObjectIdentifier = (String) objectsIterator.next();
                    System.out.println("Tri2ModelValidator.startValidationProcess()...uniqueObjectIdentifier:" + uniqueObjectIdentifier);
                    if(uniqueObjectIdentifier != null)
                    {
                        eachObjectMap = (HashMap) allOtherObjectsExceptSQL.get(uniqueObjectIdentifier);
                        System.out.println("Tri2ModelValidator.startValidationProcess()...eachObjectMap:"+ eachObjectMap);
                        if(eachObjectMap != null && eachObjectMap.size() > 0)
                        {
                            String attachedFrom       = (String) eachObjectMap.get("attachedFrom");
                            String beanIndex          = (String) eachObjectMap.get("beanIndex");
                            String onlinePatchingMode = (String) eachObjectMap.get("onlinePatchingMode");
                            String editioned          = (String) eachObjectMap.get("editioned");
                            
                            boolean onlinePatchingModeFlag = false;
                            if(onlinePatchingMode != null && !onlinePatchingMode.trim().equalsIgnoreCase(""))
                            {
                                onlinePatchingModeFlag = Boolean.valueOf(onlinePatchingMode);
                            }
                            if(onlinePatchingModeFlag && !atleastOneOnlinePatchModeExists)
                            {
                                atleastOneOnlinePatchModeExists = true;
                            }
                            if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                    && attachedFrom.equalsIgnoreCase("uploadObj"))
                            {
                                if(editioned != null && !editioned.trim().equalsIgnoreCase("")
                                        && editioned.equalsIgnoreCase("Yes"))
                                {
                                    SG_TRI2_MIGRATION_DETAILS uploadObjectBean = migDetails[Integer.parseInt(beanIndex)];
                                    if(!isEditionObjectExists)
                                    {
                                        isEditionObjectExists = true;
                                    }
                                    if(!onlinePatchingModeFlag)
                                    {
                                        if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                        {
                                            allEditionedObjects.append(uploadObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                        else
                                        {
                                            allEditionedObjects.append(", ");
                                            allEditionedObjects.append(uploadObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                    }
                                }
                            }
                            else if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                    && attachedFrom.equalsIgnoreCase("mapCVS"))
                            {
                                if(editioned != null && !editioned.trim().equalsIgnoreCase("")
                                        && editioned.equalsIgnoreCase("Yes"))
                                {
                                    SG_TRI2_CVS_MAPPED_OBJECTS mapCVSObjectBean = cvsMappedMigDetails[Integer.parseInt(beanIndex)];
                                    if(!isEditionObjectExists)
                                    {
                                        isEditionObjectExists = true;
                                    }
                                    if(!onlinePatchingModeFlag)
                                    {
                                        if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                        {
                                            allEditionedObjects.append(mapCVSObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                        else
                                        {
                                            allEditionedObjects.append(", ");
                                            allEditionedObjects.append(mapCVSObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                    }
                                }
                            }
                            else if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                    && attachedFrom.equalsIgnoreCase("mapSVN"))
                            {
                                if(editioned != null && !editioned.trim().equalsIgnoreCase("")
                                        && editioned.equalsIgnoreCase("Yes"))
                                {
                                    SG_TRI2_SVN_MAPPED_OBJECTS mapSVNObjectBean = svnMappedMigDetails[Integer.parseInt(beanIndex)];
                                    if(!isEditionObjectExists)
                                    {
                                        isEditionObjectExists = true;
                                    }
                                    if(!onlinePatchingModeFlag)
                                    {
                                        if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                        {
                                            allEditionedObjects.append(mapSVNObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                        else
                                        {
                                            allEditionedObjects.append(", ");
                                            allEditionedObjects.append(mapSVNObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                    }
                                }
                            }
                            /*
                             * IS095667 - Integration of AOM with GIT version control system(Right
                             * now AOM supports objects mapped from CVS and SVN)
                             */
                            else if(attachedFrom != null && !attachedFrom.trim().equalsIgnoreCase("") 
                                    && attachedFrom.equalsIgnoreCase("mapGIT"))
                            {
                                if(editioned != null && !editioned.trim().equalsIgnoreCase("")
                                        && editioned.equalsIgnoreCase("Yes"))
                                {
                                    SG_TRI2_GIT_MAPPED_OBJECTS mapGITObjectBean = gitMappedMigDetails[Integer.parseInt(beanIndex)];
                                    if(!isEditionObjectExists)
                                    {
                                        isEditionObjectExists = true;
                                    }
                                    if(!onlinePatchingModeFlag)
                                    {
                                        if(allEditionedObjects.toString().equalsIgnoreCase(""))
                                        {
                                            allEditionedObjects.append(mapGITObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                        else
                                        {
                                            allEditionedObjects.append(", ");
                                            allEditionedObjects.append(mapGITObjectBean.getMIG_DEV_OBJECT_NAME());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch(Exception e)
            {
                e.printStackTrace();
            }
            finally
            {
                eachObjectMap = null;
                objectsSet = null;
                objectsIterator = null;
                uniqueObjectIdentifier = null;
            }
        }
        System.out.println("Tri2ModelValidator.startValidationProcess()...isEditionObjectExists:" +  isEditionObjectExists
                + ", atleastOneOnlinePatchModeExists:" + atleastOneOnlinePatchModeExists);
        if(isOnlinePatchingEnabledForTargetInstanceFlag)
        {
            if(isEditionObjectExists && allEditionedObjects.toString().length() > 0)
            {
                returnFlag = false;
                msg.append("      [ERROR]: Online Patching Mode Flag(which is mandatory) is unchecked for the below Editioned object(s).\n");
                msg.append("      So please select Online Patching Mode flag for \n      '");
                msg.append(allEditionedObjects.toString());
                msg.append("' object(s).");
            }
            if(returnFlag && !isEditionObjectExists && atleastOneOnlinePatchModeExists)
            {
                returnFlag = false;
                msg.append("      [ERROR]: Online Patching Mode flag is checked for Non-Editioned object(s) which is required only for editioned object(s).\n");
                msg.append("      So please uncheck Online Patching Mode flag for all Non-editioned objects.");
            }
        }
        
        /*System.out.println("Tri2ModelValidator.startValidationProcess()...beanObj:" + beanObj
                + ", cvsMappedBeanObj:" + cvsMappedBeanObj + ", svnMappedBeanObj:" + svnMappedBeanObj);*/
        ArrayList copyMappedObjectIssueNumbers = new ArrayList();
        /*
         * IS073291 - Handle exceptions for "Copy Mapped Objects" Tab and "Fetch Mapped Objects" Tab, and provide proper exception messages if exception occured, when clicking "Save In Database" in attach solution objects frame.
         * Author :: serra
         * Purpose :: To check if objects are fetched in fetch mapped objects tab for tickets selected in copy mapped objects tab.
         */
        SG_TRI2_COPY_MAPPED_OBJECTS copyMappedObject = null;
        if(copyMappedObjectsArray != null)
        {
            SG_TRI2_Fetch_MAPPED_OBJECTS[] fetchMappedObjectsArray = null;
            SG_TRI2_Fetch_MAPPED_OBJECTS fetchMappedObjects = null;
            int copyMappedObjectsArrayLength = 0;

            copyMappedObjectsArrayLength = copyMappedObjectsArray.length;
        
            for(int copyMappedObjectsArrayIndex = 0; copyMappedObjectsArrayIndex < copyMappedObjectsArrayLength; copyMappedObjectsArrayIndex ++ )
            {
                if(copyMappedObjectsArray[copyMappedObjectsArrayIndex] != null
                        && copyMappedObjectsArray.length > 0)
                {
                    copyMappedObject = copyMappedObjectsArray[copyMappedObjectsArrayIndex];
                    if(copyMappedObject != null)
                    {
                        System.out.println("Tri2ModelValidator.startValidationProcess()...copyMappedObject.getIssueNumber():" + copyMappedObject.getIssueNumber()
                                + ", copyMappedObject.getIssueTitle():" + copyMappedObject.getIssueTitle()
                                + ", copyMappedObject.getProcess():" + copyMappedObject.getProcess()
                                + ", copyMappedObject.getProject():" + copyMappedObject.getProject());
                        if(copyMappedObject.getIssueNumber() != null)
                        {
                            copyMappedObjectIssueNumbers.add(copyMappedObject.getIssueNumber());
                        }
                        isTicketAvailableInCopyObjects = true;
                        fetchMappedObjectsArray = copyMappedObject.getSG_TRI2_Fetch_MAPPED_OBJECTS();
                        /*
                         * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
                         */
                        if(fetchMappedObjectsArray != null)
                        {
                            fetchMappedObjectsArrayLength = fetchMappedObjectsArray.length;

                            for(int fetchMappedObjectsArrayIndex = 0; fetchMappedObjectsArrayIndex < fetchMappedObjectsArrayLength; fetchMappedObjectsArrayIndex++)
                            {
                                fetchMappedObjects = fetchMappedObjectsArray[fetchMappedObjectsArrayIndex];
                                if(fetchMappedObjects != null)
                                {
                                    if(fetchMappedObjects.getOBJECTNAME() != null)
                                    {
                                        if(!isSolutionObjectAttached)
                                        {
                                            isSolutionObjectAttached = true;
                                        }
                                      //IS109796 - During object mapping, only modified objects should get saved (Right now all objects are getting saved)
                                        isAtleastOneObjectModified = true;
                                        if(fetchMappedObjects.getMIGRATE_FLAG_OF_TARGET_TICKET() != null 
                                                && fetchMappedObjects.getMIGRATE_FLAG_OF_TARGET_TICKET().toString().equalsIgnoreCase("true"))
                                        {
                                            if(!atleastOneMigrateFlagChecked)
                                            {
                                                atleastOneMigrateFlagChecked = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        System.out.println("Tri2ModelValidator.startValidationProcess()...isSolutionObjectAttached:" + isSolutionObjectAttached
                + ", isTicketAvailableInCopyObjects:" + isTicketAvailableInCopyObjects + ", atleastOneMigrateFlagChecked:" + atleastOneMigrateFlagChecked
                + ", copyMappedObjectIssueNumbers:" + copyMappedObjectIssueNumbers);
        String ticketAlias= "Ticket";
        ResourceBundle resourceBundle = ResourceBundle.getBundle("ContextPath");
        if(resourceBundle != null)
        {
        	String tri2URL = resourceBundle.getString("tri2MigrationServleturl");
        	ticketAlias = changeTicketToIncident(tri2URL);
        }
        if(ticketAlias == null)
        {
        	 ticketAlias= "Ticket";
        }
        System.out.println("Tri2ModelValidator.startValidationProcess()..ticketAlias" + ticketAlias);
        //IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
        if(solutionObjectIdList != null && !solutionObjectIdList.isEmpty())
        {	
        	if(previousSolutionObjectIdList != null)
        	{
        		previousSolutionObjectIdList.removeAll(solutionObjectIdList);
        	}
        	if(previousPredecessorIssuesList != null)
        	{	
        		previousPredecessorIssuesList.removeAll(solutionObjectIdList);
        	}
        }
        if(returnFlag && !isSolutionObjectAttached)
        {
            msg.append("\n");
            msg.append("[ERROR]: ");
            if(!isObjectAvailable)
            {
                if(!isTicketAvailableInCopyObjects)
                {
                    msg.append("Please attach atleast one solution object to this " +ticketAlias.toLowerCase() + ".\n");
                }
                else
                {
                    if(copyMappedObjectIssueNumbers != null && copyMappedObjectIssueNumbers.size() > 0)
                    {
                        msg.append("No objects fetched for ");
                        msg.append(copyMappedObjectIssueNumbers);
                        msg.append(ticketAlias.toLowerCase()+"s. ");
                    }
                    msg.append("Please click on 'Fetch Objects' TAB for each "+ticketAlias.toLowerCase()+ " in 'Copy Objects' TAB.\n");                
                }
            }
            else
            {
                msg.append("No changes found.\n");
            }
            returnFlag = false;
        }
        /*
         * IS085109 - Show proper validation message if all the objects attached to ticket are having migrate flag(s) as unchecked.
         */
        else if (returnFlag && !atleastOneMigrateFlagChecked)
        {
            msg.append("\n");
            msg.append("      [ERROR]: 'Migrate?' flag is unchecked for all object(s). \n");
            msg.append("      Please cross check and select 'Migrate?' flag for required objects.");
           
            returnFlag = false;
        }
        //IS109796 - During object mapping, only modified objects should get saved (Right now all objects are getting saved)
        //IS112861 - In Attach solution objects page, while saving after deleting objects (and there are no other changes in the objects), then No changes found being shown instead of processing it.
        else if(!isAtleastOneObjectModified && (previousSolutionObjectIdList == null || previousSolutionObjectIdList.isEmpty()) && (previousPredecessorIssuesList == null || previousPredecessorIssuesList.isEmpty())) 
        {
			msg.append("\n");
			msg.append("[ERROR]: ");
			msg.append("No changes found.\n");
			returnFlag = false;
		}
        
        /**
         * IS090169 - Provide depend on feature for migrations in AOM
         */
        System.out.println("Tri2ModelValidator.startValidationProcess()...returnFlag:" + returnFlag);
        if(returnFlag 
                && migrationSequences != null && migrationSequences.size() > 0
                && dependOns != null && dependOns.size() > 0)
        {
            ArrayList validationList = dependOnValidation(migrationSequences, dependOns);
            System.out.println("DependOnValidation.main()...validationList:" + validationList);
            if(validationList != null && validationList.size() > 0)
            {
                returnFlag = (Boolean) validationList.get(0);
                System.out.println("DependOnValidation.main()...returnFlag from validationList:" + returnFlag);
                if(!returnFlag)
                {
                    String validationErrorMessage = (String) validationList.get(1);
                    System.out.println("Tri2ModelValidator.startValidationProcess()...validationErrorMessage:" + validationErrorMessage);
                    if(validationErrorMessage != null)
                    {
                        msg.append(validationErrorMessage);
                    }
                }
            }
        }
        /**
         * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
         */
        if(returnFlag && migrationSequences != null && migrationSequences.size() > 0 && ((onSuccesses != null && onSuccesses.size() > 0) 
        		|| (onFailures != null && onFailures.size() > 0)))
        {
        	ArrayList validationList = onSuccessOnFailureValidation(migrationSequences, onSuccesses, onFailures, successMap, failureMap);
        	System.out.println("onSuccessOnFailureValidation.main()...validationList:" + validationList);
        	if(validationList != null && validationList.size() > 0)
            {
                returnFlag = (Boolean) validationList.get(0);
                System.out.println("onSuccessOnFailureValidation.main()...returnFlag from validationList:" + returnFlag);
                if(!returnFlag)
                {
                    String validationErrorMessage = (String) validationList.get(1);
                    System.out.println("Tri2ModelValidator.startValidationProcess()...validationErrorMessage:" + validationErrorMessage);
                    if(validationErrorMessage != null)
                    {
                        msg.append(validationErrorMessage);
                    }
                }
            }
        	
        }
        System.out.println("Tri2ModelValidator.startValidationProcess()...validation of Depend On Completed!");
        System.out.println("Tri2ModelValidator.startValidationProcess()...final returnFlag:" + returnFlag);
        return returnFlag;
    }
    
   
    
   
    
    /**
     * @author khusboo.kumari
     * IS115065 - Implement Object locking feature in AOM while mapping the objects from source environment.
     */
    private boolean checkObjectIsLocakedOrNot(String objectName, String objectType, String lockObject) 
    {
    	System.out.println("Tri2ModelValidator.checkObjectIsLocakedOrNot()...is in Execution!");
    	int count = 0;
    	ConnectionRepositoryHelper connectionRepositoryHelper = null;
        String connectionName = null;
        TrinitiJavaCode_MIG_SOLUTION_OBJECTS_R2O tri2SolutionObjects = new TrinitiJavaCode_MIG_SOLUTION_OBJECTS_R2O();
    	try {
    		connectionRepositoryHelper = ConnectionRepositoryHelper.getInstance();
            connectionName = connectionRepositoryHelper.getTri2ConnectionName();
            connection = connectionRepositoryHelper.getConnection(connectionName);
            Vector solutionObjectWhereClauseVector = new Vector();
            solutionObjectWhereClauseVector.addElement((String) objectName);
            solutionObjectWhereClauseVector.addElement("java.lang.String");
            solutionObjectWhereClauseVector.addElement((String) objectType);
            solutionObjectWhereClauseVector.addElement("java.lang.String");
            solutionObjectWhereClauseVector.addElement((String) lockObject);
            solutionObjectWhereClauseVector.addElement("java.lang.String");
            

            tri2SolutionObjects.setWhereClause("T_ISSUES_SOLUTION_OBJECTS.SOURCE_OBJECT_NAME=? AND T_ISSUES_SOLUTION_OBJECTS.OBJECT_TYPE=? AND T_ISSUES_SOLUTION_OBJECTS.LOCK_OBJECT=?");
            tri2SolutionObjects.setWhereClauseVector(solutionObjectWhereClauseVector);

            tri2SolutionObjects.setConnection(connection);
            Vector solutionObjectsVec = (Vector) tri2SolutionObjects.extractData();
            System.out.println("Tri2ModelValidator.checkObjectIsLocakedOrNot()...solutionObjectsVec.size()::" + solutionObjectsVec.size());
            count = solutionObjectsVec.size();
    	}
    	catch (Exception e)
        {
    		System.out.println("Tri2ModelValidator.checkObjectIsLocakedOrNot()..Exception : " + e.getMessage());
    		e.printStackTrace();
        } 
        finally
        {
            if(connectionRepositoryHelper != null && connectionName != null)
            {
                connectionRepositoryHelper.freeConnection(connection, connectionName);
            }
        }
    	
    	return count > 0;
	}

    private LinkedHashMap getTheAttachedFileAndValidate(LinkedHashMap inputDataMap, ResourceBundle applicationPropURLs)
    {
        System.out.println("Tri2ModelValidator.getTheAttachedFileAndValidate()...is in Execution!");
        long startTime = System.currentTimeMillis();
        LinkedHashMap outputDataMapFromServlet = null;
        URL migrationServlet = null;
        URLConnection migrationServletConnection = null;
        ObjectOutputStream outputToServletStream = null;
        ObjectInputStream outputFromServletStream = null;
        String objectDownloaderServlet = null;
        try
        {
            objectDownloaderServlet = applicationPropURLs.getString("tri2ObjectDownloaderServlet");
            migrationServlet = new URL(objectDownloaderServlet);
            migrationServletConnection = migrationServlet.openConnection();

            migrationServletConnection.setDoInput(true);
            migrationServletConnection.setDoOutput(true);
            migrationServletConnection.setUseCaches(false);
            migrationServletConnection.setDefaultUseCaches(false);
            migrationServletConnection.setRequestProperty("Content-Type", "application/x-java-serialized-object");

            outputToServletStream = new ObjectOutputStream(migrationServletConnection.getOutputStream());
            System.out.println("Tri2ModelValidator.getTheAttachedFileAndValidate()...is in Execution!  ....inputDataMap :- "+inputDataMap);
            outputToServletStream.writeObject(inputDataMap);
            outputToServletStream.flush();
            outputToServletStream.close();

            outputFromServletStream = new ObjectInputStream(migrationServletConnection.getInputStream());
            outputDataMapFromServlet = (LinkedHashMap) outputFromServletStream.readObject();
            outputFromServletStream.close();

            System.out.println("Tri2ModelValidator.getTheAttachedFileAndValidate()...outputDataMapFromServlet ::"
                    + outputDataMapFromServlet);
        }
        catch(java.net.ConnectException netException)
        {
            // throw netException;
            netException.printStackTrace();
        }
        catch(java.net.SocketException se)
        {
            se.printStackTrace();
        }
        catch(Exception exp)
        {
            exp.printStackTrace();
        }

        finally
        {
            migrationServlet = null;
            migrationServletConnection = null;
            outputToServletStream = null;
            outputFromServletStream = null;
        }
        long endTime = System.currentTimeMillis();
        System.out.println("Tri2ModelValidator.getTheAttachedFileAndValidate()(ENDS) : endTime - startTime) " + (endTime - startTime) + " ms.");
        return outputDataMapFromServlet;
    }

    /**
     * @author sutukuru Purpose: This method is added to validate the SQL and
     *         ORACLE related Object Types.
     * @param objectType
     * @return
     */
    private boolean isSchemaRequired(String objectType)
    {
        boolean isSchemaReq = false;
        if(objectType.equalsIgnoreCase("SQL")
                || objectType.equalsIgnoreCase("CONCURRENT_PROGRAM_NAME")
                || objectType.equalsIgnoreCase("LOOKUP_TYPE")
                || objectType.equalsIgnoreCase("ORACLE_FORMS")
                || objectType.equalsIgnoreCase("ORACLE_WORKFLOW")
                || objectType.equalsIgnoreCase("PROCEDURE")
                || objectType.equalsIgnoreCase("SEQUENCE")
                || objectType.equalsIgnoreCase("SYNONYM")
                || objectType.equalsIgnoreCase("TABLE")
                || objectType.equalsIgnoreCase("TRIGGER")
                || objectType.equalsIgnoreCase("VIEW")
                || objectType.equalsIgnoreCase("INDEX")
                || objectType.equalsIgnoreCase("PL/SQL")
                || objectType.equalsIgnoreCase("FUNCTION")
                || objectType.equalsIgnoreCase("PACKAGE")
                || objectType.equalsIgnoreCase("MATERIALIZED VIEW")
                || objectType.equalsIgnoreCase("LOB")
                || objectType.equalsIgnoreCase("EXECUTABLE_NAME")
                || objectType.equalsIgnoreCase("FUNCTION_NAME")
                || objectType.equalsIgnoreCase("ID_FLEX_CODE")
                || objectType.equalsIgnoreCase("PROFILE_NAME")
                || objectType.equalsIgnoreCase("REQUEST_GROUP_NAME")
                || objectType.equalsIgnoreCase("BNE_LAYOUTS")
                || objectType.equalsIgnoreCase("MENU_NAME")
                || objectType.equalsIgnoreCase("REQUEST_SET_NAME")
                || objectType.equalsIgnoreCase("FLEX_VALUE_SET_NAME")
                || objectType.equalsIgnoreCase("FND_USER_NAME")
                || objectType.equalsIgnoreCase("FND_RESPONSIBILITY_KEY")
                || objectType.equalsIgnoreCase("BNE_PARAMLIST")
                || objectType.equalsIgnoreCase("XDO_DS_DEFINITIONS")
                || objectType.equalsIgnoreCase("FLEX_VALUE_SET_VALUE_NAME")
                || objectType.equalsIgnoreCase("FORM_NAME")
                || objectType.equalsIgnoreCase("DESCRIPTIVE_FLEXFIELD_NAME")
                || objectType.equalsIgnoreCase("LOOKUP_TYPE")
                || objectType.equalsIgnoreCase("FND_FORM_FUNCTION_NAME")
                || objectType.equalsIgnoreCase("PRINTER_STYLE_NAME")
                || objectType.equalsIgnoreCase("FND_ATTACHMENT_FUNCTIONS")
                || objectType.equalsIgnoreCase("MESSAGE_NAME")
                || objectType.equalsIgnoreCase("OAF-WEB_UI")
                || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-COPY")
                || objectType.equalsIgnoreCase("OAF_PERSONALIZATIONS-WEB_UI")
                || objectType.equalsIgnoreCase("OAF_STANDARD-JPX")
                /**
                 * IS070900 - Provide facility to migrate Database Grant/Type objects through TRI2 Migration Tool.
                 */
                || objectType.equalsIgnoreCase("GRANT")
                || objectType.equalsIgnoreCase("TYPE")
                /**
                 * IS073907-Migration of Collection Plan LDTS through AOM
                 * IS073908-Migration of Collection Element LDTS through AOM
                 */
                || objectType.equalsIgnoreCase("COLLECTION_PLAN")
                || objectType.equalsIgnoreCase("COLLECTION_ELEMENT")
                /**
                 * IS085523 - AME (Approvals Management Engine) Objects migration through AOM
                 */
                || objectType.equalsIgnoreCase("AME_ATTRIBUTE")
                || objectType.equalsIgnoreCase("AME_ATTRIBUTE_USAGES")
                || objectType.equalsIgnoreCase("AME_ATTRIBUTE_CONDITIONS")
                || objectType.equalsIgnoreCase("AME_APPROVAL_GROUPS")
                || objectType.equalsIgnoreCase("AME_APPROVAL_GROUP_CONFIG")
                || objectType.equalsIgnoreCase("AME_RULES")
                || objectType.equalsIgnoreCase("AME_RULE_ACTION_TYPE_USAGES")
                /**
                 * IS093015 - Provision to migrate Web ADI Integrator, Web ADI Mapping and Web ADI Content objects through Migration Tool
                 */
                || objectType.equalsIgnoreCase("BNE_MAPPING")
                || objectType.equalsIgnoreCase("BNE_CONTENT")
                || objectType.equalsIgnoreCase("BNE_INTEGRATOR")
                || objectType.equalsIgnoreCase("PLSQL_ANONYMOUS_BLOCK"))
        {
            isSchemaReq = true;
        }

        System.out.println("Tri2ModelValidator.isSchemaRequired()...isSchemaReq:" + isSchemaReq);
        return isSchemaReq;
    }

    private boolean isValidationRequired(String objectType)
    {
        boolean validate = false;
        if(objectType.equalsIgnoreCase("SQL")
                || objectType.equalsIgnoreCase("PROCEDURE")
                || objectType.equalsIgnoreCase("SEQUENCE")
                || objectType.equalsIgnoreCase("SYNONYM")
                || objectType.equalsIgnoreCase("TABLE")
                || objectType.equalsIgnoreCase("TRIGGER")
                || objectType.equalsIgnoreCase("VIEW")
                || objectType.equalsIgnoreCase("INDEX")
                || objectType.equalsIgnoreCase("PL/SQL")
                || objectType.equalsIgnoreCase("FUNCTION")
                || objectType.equalsIgnoreCase("PACKAGE")
                || objectType.equalsIgnoreCase("MATERIALIZED VIEW")
                || objectType.equalsIgnoreCase("PLSQL_ANONYMOUS_BLOCK")

                /**
                 * IS070900 - Provide facility to migrate Database Grant/Type objects through TRI2 Migration Tool.
                 */
                || objectType.equalsIgnoreCase("GRANT")
                || objectType.equalsIgnoreCase("TYPE")
                /**
                 * 
                 * IS073963 - If we upload corrupted zip using JAR as object type in Upload Objects, even if it is showing as Exception Invalid zip while saving attached objects, still it's proceeding to save into database
                 */
                || objectType.equalsIgnoreCase("JAR")
                || objectType.equalsIgnoreCase("UPGRADE_PACK")
                /**
                 * 
                 * IS083932 - Validate EAR_FILE object at the time of attaching/mapping to a ticket to check whether object is corrupted or not.
                 */
                || objectType.equalsIgnoreCase("EAR_FILE"))
        {
            validate = true;
        }
        System.out.println("Tri2ModelValidator.isValidationRequired()...validate:" + validate);
        return validate;
    }

    /**
     * @param objectType
     * @return {@link boolean}
     * @since 19th Dec, 2012 To validate all the AOL Object types.
     */
    private boolean isObjectTypeAvailable(String objectType)
    {
        boolean availableFlag = false;
        if(objectType.equalsIgnoreCase("CONCURRENT_PROGRAM_NAME")
                || objectType.equalsIgnoreCase("REQUEST_GROUP_NAME")
                || objectType.equalsIgnoreCase("REQUEST_SET_NAME")
                || objectType.equalsIgnoreCase("REQUEST_SET_LINK_NAME")
                || objectType.equalsIgnoreCase("FLEX_VALUE_SET_NAME")
                || objectType.equalsIgnoreCase("DESCRIPTIVE_FLEXFIELD_NAME")
                || objectType.equalsIgnoreCase("PROFILE_NAME")
                || objectType.equalsIgnoreCase("MENU_NAME")
                || objectType.equalsIgnoreCase("PRINTER_STYLE_NAME")
                || objectType.equalsIgnoreCase("LOOKUP_TYPE")
                || objectType.equalsIgnoreCase("FND_RESPONSIBILITY_KEY")
                || objectType.equalsIgnoreCase("FORM_NAME")
                || objectType.equalsIgnoreCase("ORACLE_FORMS")
                || objectType.equalsIgnoreCase("APPS_FUNCTION")
                || objectType.equalsIgnoreCase("ID_FLEX_CODE")
                || objectType.equalsIgnoreCase("CUSTOM CLASS")
                || objectType.equalsIgnoreCase("BNE_LAYOUTS")
                || objectType.equalsIgnoreCase("EXECUTABLE_NAME")
                || objectType.equalsIgnoreCase("FND_USER_NAME")
                || objectType.equalsIgnoreCase("XML_PUB_REPORTS")
                || objectType.equalsIgnoreCase("XDO_DS_DEFINITIONS")
                || objectType.equalsIgnoreCase("ORACLE_WORKFLOW")
                || objectType.equalsIgnoreCase("ORACLE_REPORTS")
                || objectType.equalsIgnoreCase("FUNTION_NAME")
                || objectType.equalsIgnoreCase("BNE_PRARAMLIST")
                || objectType.equalsIgnoreCase("VALUE SETS WITH VALUES")
                || objectType.equalsIgnoreCase("FND_FORM_FUNCTION_NAME")
                || objectType.equalsIgnoreCase("INTEGRATION_REPOSITORY_OBJECT")
                /**
                 * IS073907-Migration of Collection Plan LDTS through AOM
                 * IS073908-Migration of Collection Element LDTS through AOM
                 */
                || objectType.equalsIgnoreCase("COLLECTION_PLAN")
                || objectType.equalsIgnoreCase("COLLECTION_ELEMENT")
                /**
                 * Added as Oracle Apps Top and Short name are required for FUNCTION_NAME object type
                 */
                || objectType.equalsIgnoreCase("FUNCTION_NAME")
                /**
                 * IS085523 - AME (Approvals Management Engine) Objects migration through AOM
                 */
                || objectType.equalsIgnoreCase("AME_ATTRIBUTE")
                || objectType.equalsIgnoreCase("AME_ATTRIBUTE_USAGES")
                || objectType.equalsIgnoreCase("AME_ATTRIBUTE_CONDITIONS")
                || objectType.equalsIgnoreCase("AME_APPROVAL_GROUPS")
                || objectType.equalsIgnoreCase("AME_APPROVAL_GROUP_CONFIG")
                || objectType.equalsIgnoreCase("AME_RULES")
                || objectType.equalsIgnoreCase("AME_RULE_ACTION_TYPE_USAGES")
                /**
                 * IS093015 - Provision to migrate Web ADI Integrator, Web ADI Mapping and Web ADI Content objects through Migration Tool
                 */
                || objectType.equalsIgnoreCase("BNE_MAPPING")
                || objectType.equalsIgnoreCase("BNE_CONTENT")
                || objectType.equalsIgnoreCase("BNE_INTEGRATOR")
                /**
                 * IS113108 - Provision to migrate Control (.ctl) files through AOM tool.
                 */
                || objectType.equalsIgnoreCase("CONTROL_FILES")
               //IS123662 - Oracle Application Short Name and Top fields are not being validated for MESSAGE NAME object type while mapping the solution objects.
        	    || objectType.equalsIgnoreCase("MESSAGE_NAME"))
        	    
        {
            availableFlag = true;
        }
        System.out.println("Tri2ModelValidator.iSObjectTypeAvailable()...availableFlag:" + availableFlag);
        return availableFlag;
    }

    /**
     * @param objectType
     * @return {@link boolean}
     * @author S.ROY Exceptional case, where Appl_TOP and Appl_SHORT_NAME is not
     *         required for some AOL Objects.
     */
    private boolean isApplicationTopRequired(String objectType)
    {
        boolean applicationTopFlag = true;
        /*Commented this block as Oracle Apps Top and Oracle Apps Shortname is required for MENU_NAME as well
         * if(objectType.equalsIgnoreCase("MENU_NAME"))
        {
            applicationTopFlag = false;
        }*/
        //IS112903 - FLEX_VALUE_SET_NAME and FLEX_VALUE_SET_VALUE_NAME objects application top validation is not required at migration level.
        if(objectType.equalsIgnoreCase("FLEX_VALUE_SET_NAME") || objectType.equalsIgnoreCase("FLEX_VALUE_SET_VALUE_NAME"))
        {
            applicationTopFlag = false;
        }
        System.out.println("Tri2ModelValidator.isApplicationTopRequired()...applicationTopFlag:" + applicationTopFlag);
        return applicationTopFlag;
    }

    /*
     * (non-Javadoc)
     * @see gps.build.ModelValidator#getOutputData() Overridden method form
     * ModelValidator Class. This method will return the WARNING string to be
     * shown in dialog. S.ROY on 19th Dec, 12.
     */
    public String getOutputData()
    {
        String message = null;
        if(msg == null || msg.toString().length() == 0)
        {
            message = "No output from the Client side Validator, check at server side error";
        }
        else
        {
            message = msg.toString();
            System.out.println("Tri2ModelValidator.getOutputData()...message:" + msg);
        }

        msg = null; // Make it eligible for Garbage Collection.
        Runtime.getRuntime().gc(); // Indicating JVM to recycle.
        return message;
    }

    /**
     * @param genericBean
     * @return {@link Boolean} This method receive the call form
     *         startValidationProcess and map the exact bean (CVS map / Upload
     *         obj) to genericValidator.
     * @author S.ROY
     * @since 20th Dec, 12.
     */
    private boolean validateFileExtension(Object genericBean)
    {

        if(genericBean == null)
        {
            return false;
        }
        SG_TRI2_MIGRATION_DETAILS beanObj = null;
        SG_TRI2_CVS_MAPPED_OBJECTS cvsMappedBeanObj = null;
        SG_TRI2_SVN_MAPPED_OBJECTS svnMappedBeanObj = null;
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        SG_TRI2_GIT_MAPPED_OBJECTS gitMappedBeanObj = null;
        String objectType = null;
        String objectName = null;
        String extension = "";

        if(genericBean instanceof SG_TRI2_MIGRATION_DETAILS)
        {
            System.out.println("*** Upload Objects *** File extension validation");
            beanObj = (SG_TRI2_MIGRATION_DETAILS) genericBean;
            objectType = beanObj.getMIG_DEV_OBJECT_TYPE();
            objectName = beanObj.getMIG_DEV_OBJECT_NAME();
            /**@author teja.miryala
             * IS078592 - Provide proper validation while uploading a file for object type as SQL in Upload Objects tab.
             */
            if(objectType.equalsIgnoreCase("SQL"))
            {
                /*
                 * Modified objectName.indexOf() with objectName.lastIndexOf()
                 * if file name contains . (dot) then extension is being taken as wrong
                 * */
                String endsWith = objectName.substring(objectName.lastIndexOf('.') + 1);
                System.out.println("Tri2ModelValidator.validateFileExtension()...endsWith:" + endsWith);
                String extensions = "sql,prc,fnc,pck,pls,plb,pks,pkb,dbf,lst";
                String[] extend = null;
                extend = extensions.split(",");
                boolean checkFlag = false;
                for(int i = 0 ; i < extend.length ; i++)
                {
                    String compare = extend[i];
                    if(compare.equals(endsWith))
                    {
                        if(objectName.lastIndexOf(".") != - 1)
                            extension = objectName.substring(objectName.lastIndexOf(".") + 1, objectName.length());
                        this.genericValidator(objectName, objectType, extension);
                        checkFlag = true;
                        break;
                    }
                }
                if(checkFlag == Boolean.FALSE)
                {
                    msg.append("\n ");
                    msg.append(beanObj.getMIG_DEV_OBJECT_NAME());
                    msg.append("\n");
                    msg.append("      [ERROR]: OBJECT TYPE 'SQL' DOES NOT SUPPPORTS ."
                            + endsWith + " FILE .\n ");
                    returnFlag = false;
                }
            }
            if(objectName.lastIndexOf(".") != - 1)
                extension = objectName.substring(objectName.lastIndexOf(".") + 1, objectName.length());
                this.genericValidator(objectName, objectType, extension);
        }

        if(genericBean instanceof SG_TRI2_CVS_MAPPED_OBJECTS)
        {
            System.out.println("*** Map CVS Objects *** File extension validation");
            cvsMappedBeanObj = (SG_TRI2_CVS_MAPPED_OBJECTS) genericBean;
            objectType = cvsMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
            objectName = cvsMappedBeanObj.getMIG_DEV_OBJECT_NAME();
            if(objectName.lastIndexOf(".") != - 1)
                extension = objectName.substring(objectName.lastIndexOf(".") + 1, objectName.length());
            this.genericValidator(objectName, objectType, extension);
        }

        if(genericBean instanceof SG_TRI2_SVN_MAPPED_OBJECTS)
        {
            System.out.println("*** Map SVN Objects *** File extension validation");
            svnMappedBeanObj = (SG_TRI2_SVN_MAPPED_OBJECTS) genericBean;
            objectType = svnMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
            objectName = svnMappedBeanObj.getMIG_DEV_OBJECT_NAME();
            if(objectName.lastIndexOf(".") != - 1)
                extension = objectName.substring(objectName.lastIndexOf(".") + 1, objectName.length());
            this.genericValidator(objectName, objectType, extension);
        }
        /*
         * IS095667 - Integration of AOM with GIT version control system(Right
         * now AOM supports objects mapped from CVS and SVN)
         */
        if(genericBean instanceof SG_TRI2_GIT_MAPPED_OBJECTS)
        {
            System.out.println("*** Map GIT Objects *** File extension validation");
            gitMappedBeanObj = (SG_TRI2_GIT_MAPPED_OBJECTS) genericBean;
            objectType = gitMappedBeanObj.getMIG_DEV_OBJECT_TYPE();
            objectName = gitMappedBeanObj.getMIG_DEV_OBJECT_NAME();
            if(objectName.lastIndexOf(".") != - 1)
                extension = objectName.substring(objectName.lastIndexOf(".") + 1, objectName.length());
            this.genericValidator(objectName, objectType, extension);
        }
        return this.returnFlag;

    }

    /**
     * @author S.ROY
     * @since 20th Dec, 12
     * @param objectName
     * @param objectType
     * @param extension
     * @return {@link Boolean} This generic Validator will validate all the
     *         Mapped or attached File extn. with compatible object type and
     *         return the result Flag.
     */
    private boolean genericValidator(String objectName, String objectType, String extension)
    {

        Objects objectEnumPool = null;
        if(objectType != null)
        {
            try
            {
                objectType = this.trimFileNameSpaces(objectType);
                objectEnumPool = Objects.getObjectFromPool(objectType);
            }
            catch(IllegalArgumentException e)
            {
                System.out.println("Tri2ModelValidator.genericValidator().. :::: "
                        + e.getMessage());

                if(objectType.equalsIgnoreCase("SQL")
                        || objectType.equalsIgnoreCase("PL/SQL"))
                {
                    objectEnumPool = Objects.SQL;
                }
                else if(this.isObjectTypeAvailable(objectType))
                {
                    objectEnumPool = Objects.ANY_AOL_OBJECT;
                }
                else
                {
                    objectEnumPool = Objects.DEFAULT_VALUE;
                }

            }
            catch(NullPointerException e)
            {
                System.out.println("Tri2ModelValidator.genericValidator()....... ::::::: "
                        + e.getMessage());
            }
            catch(Exception e)
            {
                e.printStackTrace();
            }

        }

     /*//   switch(objectEnumPool)
        {
            case SQL:
                System.out.println("Tri2ModelValidator.genericValidator()....Case is SQL ::: PL/SQL");
                if( ! (extension.equalsIgnoreCase("sql")
                        || extension.equalsIgnoreCase("prc")
                        || extension.equalsIgnoreCase("fnc")
                        || extension.equalsIgnoreCase("pck")
                        || extension.equalsIgnoreCase("pls")
                        || extension.equalsIgnoreCase("plb")
                        || extension.equalsIgnoreCase("pks")
                        || extension.equalsIgnoreCase("pkb")
                        || extension.equalsIgnoreCase("dbf") || extension.equalsIgnoreCase("lst")))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    returnFlag = false;
                }
                break;

            case ORACLE_REPORTS:
                System.out.println("Tri2ModelValidator.genericValidator()  Case is ::: ORACLE_REPORTS");
                if( ! extension.equalsIgnoreCase("rdf"))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    // msg.append("\n " + objectName + "\n");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    returnFlag = false;
                }
                break;

            case ORACLE_FORMS:

                System.out.println("Tri2ModelValidator.genericValidator() ::: Case is ORACLE_FORMS ");
                if( ! extension.equalsIgnoreCase("fmb"))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    // msg.append("\n " + objectName + "\n");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    returnFlag = false;
                }
                break;

            case ORACLE_WORKFLOW:

                System.out.println("Tri2ModelValidator.genericValidator() ::: Case is ORACLE_WORKFLOW ");
                if( ! extension.equalsIgnoreCase("wft"))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    // msg.append("\n " + objectName + "\n");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    // msg.append("      [ERROR]: FILE EXTENSION ." + extension
                    // + " IS NOT COMPATIBLE WITH OBJECT TYPE: " + objectType +
                    // ".\n");
                    returnFlag = false;
                }
                break;

            case XML_PUB_REPORTS:

                System.out.println("Tri2ModelValidator.validateFileExtension() ::: Case is XML_PUB_REPORTS ");
                // Added all the possible object extension types for Publisher
                // report
                if( ! (extension.equalsIgnoreCase("rtf")
                        || extension.equalsIgnoreCase("pdf")
                        || extension.equalsIgnoreCase("xls")
                        || extension.equalsIgnoreCase("xsl-fo")
                        || extension.equalsIgnoreCase("xsl-html")
                        || extension.equalsIgnoreCase("xsl-xml")
                        || extension.equalsIgnoreCase("xsltext")
                        || extension.equalsIgnoreCase("xsd")
                        || extension.equalsIgnoreCase("xml") || extension.equalsIgnoreCase("rtf-etext")))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    returnFlag = false;
                }
                break;

            case EXECUTE_SHELL_SCRIPT:

                System.out.println("Tri2ModelValidator.validateFileExtension() ::: Case is EXECUTE_SHELL_SCRIPT ");
                if( ! extension.equalsIgnoreCase("sh"))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    // msg.append("\n " + objectName + "\n");
                    // msg.append("      [ERROR]: FILE EXTENSION ." + extension
                    // + " IS NOT COMPATIBLE WITH OBJECT TYPE: " + objectType +
                    // ".\n");
                    returnFlag = false;
                }
                break;

            case ANY_AOL_OBJECT:

                System.out.println("Tri2ModelValidator.genericValidator() ::: Case is ANY_AOL_OBJECT");
                if( ! (extension.equalsIgnoreCase("ldt") || extension.equalsIgnoreCase("ildt")))
                {
                    msg.append("\n ");
                    msg.append(objectName);
                    msg.append("\n ");
                    msg.append("      [ERROR]: FILE EXTENSION .");
                    msg.append(extension);
                    msg.append(" IS NOT COMPATIBLE WITH OBJECT TYPE: ");
                    msg.append(objectType);
                    msg.append(".\n");
                    // msg.append("\n " + objectName + "\n");
                    // msg.append("      [ERROR]: FILE EXTENSION ." + extension
                    // + " IS NOT COMPATIBLE WITH OBJECT TYPE: " + objectType +
                    // ".\n");
                    returnFlag = false;
                }
                break;

            default:

                System.out.println("Tri2ModelValidator.genericValidator().... :::::: NORMAL CASE !!");
                break;
        }*/
        return this.returnFlag;
    }

    /**
     * @author S.ROY
     * @since 20th Dec, 12 Holds the Object type pool for all the different
     *        types of Object, and return the proper mapping for iteration of
     *        object types while validating File extn.
     */
    private enum Objects
    {
    	//IS097480 - Provision to migrate oracle form libraries (custom.pll) through AOM
        SQL, ORACLE_REPORTS, ORACLE_FORMS, ORACLE_WORKFLOW, EXECUTE_SHELL_SCRIPT, XML_PUB_REPORTS, ANY_AOL_OBJECT, DEFAULT_VALUE,ORACLE_FORM_LIBRARIES;

        /**
         * @param objectType
         * @return {@link Constant}
         * @throws IllegalArgumentException
         */
        public static Objects getObjectFromPool(String objectType) throws IllegalArgumentException
        {
            if(SQL.name().equalsIgnoreCase(objectType))
            {
                return Objects.SQL;
            }
            if(ORACLE_FORMS.name().equalsIgnoreCase(objectType))
            {
                return Objects.ORACLE_FORMS;
            }
            if(ORACLE_REPORTS.name().equalsIgnoreCase(objectType))
            {
                return Objects.ORACLE_REPORTS;
            }
            if(ORACLE_WORKFLOW.name().equalsIgnoreCase(objectType))
            {
                return Objects.ORACLE_WORKFLOW;
            }
            if(EXECUTE_SHELL_SCRIPT.name().equalsIgnoreCase(objectType))
            {
                return Objects.EXECUTE_SHELL_SCRIPT;
            }
            if(XML_PUB_REPORTS.name().equalsIgnoreCase(objectType))
            {
                return Objects.XML_PUB_REPORTS;
            }
            //IS097480 - Provision to migrate oracle form libraries (custom.pll) through AOM
            if(ORACLE_FORM_LIBRARIES.name().equalsIgnoreCase(objectType))
            {
                return Objects.ORACLE_FORM_LIBRARIES;
            }
            throw new IllegalArgumentException("Case is Not found in Common Object Pool");

        }
    }

    /**
     * @author S.ROY
     * @since 20th Dec, 12
     * @param fileName
     * @return {@link String} This method is used to trim the white spaces in
     *         object type.
     */
    private String trimFileNameSpaces(String fileName)
    {
        if(fileName != null)
        {
            fileName = fileName.trim();
            fileName = fileName.replace(" ", "_");
            return fileName;
        }
        System.out.println("Tri2ModelValidator.trimFileNameSpaces().... :::: "
                + fileName);
        throw new NullPointerException("The Object Type is NULL");
    }

    private String html2text(String html)
    {
        System.out.println("Tri2ModelValidator.html2text()");
        return Jsoup.parse(html).text();
    }

    private void processOAFZipsForValidation(ArrayList outerList)
    {
        System.out.println("Tri2ModelValidator.processOAFZipsForValidation()");
        int outerListSize = outerList.size();
        for(int index = 0; index < outerListSize; index ++ )
        {
            HashMap innerHashMap = (HashMap) outerList.get(index);
            Iterator iterator = innerHashMap.entrySet().iterator();
            while(iterator.hasNext())
            {
                Map.Entry entry = (Map.Entry) iterator.next();
                String objectType = (String) entry.getKey();
                String user_TimeStamp = (String) entry.getValue();
                System.out.println("objectType : " + objectType
                        + " user_TimeStamp :" + user_TimeStamp);
                callJSPForValidaition(objectType, user_TimeStamp);
            }

        }
    }

    private void callJSPForValidaition(String objectType, String user_TimeStamp)
    {
        System.out.println("Tri2ModelValidator.callJSPForValidaition()");
        String response = "";
        ResourceBundle resourceBundle = ResourceBundle.getBundle("ContextPath");
        String requiredURL = resourceBundle.getString("tabimplurl");
        System.out.println("Tri2ModelValidator.callJSPForValidaition()...requiredURL:" + requiredURL + ", user_TimeStamp:" + user_TimeStamp);
        objectType = URLEncoder.encode(objectType);
        user_TimeStamp = URLEncoder.encode(user_TimeStamp);
        
        String jspURL = requiredURL
                + "jsp/customlinksjsp/validateOafZip.jsp?objectType="
                + objectType + "&mig_dev_object=" + user_TimeStamp;
        System.out.println("Tri2ModelValidator.callJSPForValidaition()...objectType:" + objectType 
                + ", user_TimeStamp:" + user_TimeStamp + ", jspURL:" + jspURL);
        // Create an instance of HttpClient.
        HttpClient client = new HttpClient();
        // Create a method instance.
        GetMethod method = new GetMethod(jspURL);

        /* Provide custom retry handler is necessary method.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler(3, false)); */

        try
        {
            // Execute the method.
            int statusCode = client.executeMethod(method);

            if(statusCode != HttpStatus.SC_OK)
            {
                System.err.println("Method failed: " + method.getStatusLine());
            }

            // Read the response body.
            String responseBody = method.getResponseBodyAsString();

            /* Deal with the response.
               Use caution: ensure correct character encoding and is not binary data */
            response = html2text(responseBody);
            System.out.println("Tri2ModelValidator.callJSPForValidaition()...response:" + response);
        }
        catch(Exception e)
        {
            System.err.println("Fatal transport error: " + e.getMessage());
            e.printStackTrace();
        }
        finally
        {
            // Release the connection.
            method.releaseConnection();
        }

        if(response.indexOf("valid oaf zip") == - 1)
        {
            msg.append("\n ");
            msg.append("      [ERROR]:" + response + "  \n ");
            returnFlag = false;
        }
    }
    /*
     * IS089199- Provide an option for database type(Oracle/Postgre) at object level while attaching/mapping SQL objects and migration should 
     * happen based on the target instance's database type(ignoring other objects of different database type)
     */
    private  boolean isSQLObjectType(String objectType)
    {
        boolean isSQLObjectType = false;
        if(objectType.equalsIgnoreCase("FUNCTION")
        		|| objectType.equalsIgnoreCase("GRANT")
        		|| objectType.equalsIgnoreCase("INDEX")
        		|| objectType.equalsIgnoreCase("MATERIALIZED VIEW")
        		|| objectType.equalsIgnoreCase("PACKAGE")
        		|| objectType.equalsIgnoreCase("PROCEDURE")
        		|| objectType.equalsIgnoreCase("SEQUENCE")
        		|| objectType.equalsIgnoreCase("SQL")
        		|| objectType.equalsIgnoreCase("SYNONYM")
        		|| objectType.equalsIgnoreCase("TABLE")
        		|| objectType.equalsIgnoreCase("TRIGGER")
        		|| objectType.equalsIgnoreCase("TYPE")
        		|| objectType.equalsIgnoreCase("VIEW")
        		|| objectType.equalsIgnoreCase("PLSQL_ANONYMOUS_BLOCK"))
        {
            isSQLObjectType = true;
        }
        return isSQLObjectType;
    }
    
    /**
     * This method validates Depend On configuration
     * @param migrationSequences
     * @param dependOns
     * @return validationList
     * @author vkodapaka
     */
    public ArrayList dependOnValidation(ArrayList<Double> migrationSequences, ArrayList<String> dependOns)
    {
        System.out.println("Tri2ModelValidator.dependOnValidation()...is in Execution!");
        long startTime = System.currentTimeMillis();
        boolean validationFlag = true;
        String  validationErrorMessage = null;
        ArrayList validationList = null;
        try
        {
            boolean atleastOneDependOnExists = false;
            if(migrationSequences.size() == dependOns.size())
            {
                atleastOneDependOnExists = containsAtleastOneDependOn(dependOns);
                boolean migrationSequenceIsNotCompletelyFilled = false;
                if(atleastOneDependOnExists)
                {
                    /**
                     * 1. 'Migration Sequence' should be filled for all objects.
                     */
                    migrationSequenceIsNotCompletelyFilled = checkMigrationSequenceIsCompletelyFilled(migrationSequences);
                    boolean hasDuplicateMigrationSequence = false;
                    if(migrationSequenceIsNotCompletelyFilled)
                    {
                        validationFlag = false;
                        validationErrorMessage = "'Migration Sequence' should be filled for all objects.";
                    }
                    else
                    {
                        /**
                         * 2. Duplicates are not allowed in 'Migration Sequence' column.
                         */
                        hasDuplicateMigrationSequence = checkDuplicatesInMigrationSequence(migrationSequences);
                        boolean dependOnIsNotAvailableInMigrationSequence = false;
                        if(hasDuplicateMigrationSequence)
                        {
                            validationFlag = false;
                            validationErrorMessage = "Duplicates are not allowed in 'Migration Sequence' column.";
                        }
                        else
                        {
                            /**
                             * 3. Provided 'Depend On' value(s) is/are not available in 'Migration Sequence' column.
                             */
                            dependOnIsNotAvailableInMigrationSequence = checkAllDependOnsAreAvailableInMigrationSequence(migrationSequences, dependOns);
                            boolean sameObjectIsNotProvidedAsDependOn = false;
                            if(!dependOnIsNotAvailableInMigrationSequence)
                            {
                                validationFlag = false;
                                validationErrorMessage = "Provided 'Depend On' value(s) is/are not available in 'Migration Sequence' column.";
                            }
                            else
                            {
                                /**
                                 * 4. The same object shouldn't be provided as 'Depend On' to the same object.
                                 */
                                sameObjectIsNotProvidedAsDependOn = checkIfSameObjectProvidedAsDependOn(migrationSequences, dependOns);
                                boolean firstObjectShouldNotHaveDependOn = false; 
                                if(!sameObjectIsNotProvidedAsDependOn)
                                {
                                    validationFlag = false;
                                    validationErrorMessage = "The same object shouldn't be provided as 'Depend On' to the same object.";
                                }
                                else
                                {
                                    /**
                                     * 5. The first object in 'Migration Sequence' shouldn't have any 'Depend On'.
                                     */
                                    firstObjectShouldNotHaveDependOn = checkFirstObjectShouldNotHaveDependOn(migrationSequences, dependOns);
                                    boolean objectsDontHaveHigherMigrationSequenceAsDependOn = false;
                                    if(!firstObjectShouldNotHaveDependOn)
                                    {
                                        /**
                                         * 6. Higher 'Migration Sequence' shouldn't be provided as 'Depend On' for the object which has a lower 'Migration Sequence'.
                                         */
                                        objectsDontHaveHigherMigrationSequenceAsDependOn = checkObjectsDontHaveHigherMigrationSequenceAsDependOn(migrationSequences, dependOns);
                                        if(!objectsDontHaveHigherMigrationSequenceAsDependOn)
                                        {
                                            validationFlag = false;
                                            validationErrorMessage = "Higher 'Migration Sequence' shouldn't be provided as 'Depend On' for the object which has a lower 'Migration Sequence'.";
                                        }
                                    }
                                    else
                                    {
                                        validationFlag = false;
                                        validationErrorMessage = "The first object in 'Migration Sequence' shouldn't have any 'Depend On'.";
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                validationFlag = false;
                validationErrorMessage = "Configured Migration Sequences and Depend Ons are not of same size.";
            }
        }
        catch(Exception e)
        {
            validationFlag = false;
            e.printStackTrace();
        }
        finally
        {
            validationList = new ArrayList();
            validationList.add(validationFlag);
            validationList.add(validationErrorMessage);
        }
        //System.out.println("DependOnValidation.dependOnValidation()...validationList:" + validationList);
        long endTime = System.currentTimeMillis();
        System.out.println("Tri2ModelValidator.dependOnValidation()(ENDS) : endTime - startTime):" + (endTime - startTime) + " ms.");
        return validationList;
    }

    /**
     * This method checks that atleast one Depend On is configured or not
     * @param dependOns
     * @return atleastOneDependOnExists
     * @author vkodapaka
     */
    public boolean containsAtleastOneDependOn(ArrayList<String> dependOns)
    {
        boolean atleastOneDependOnExists = false;
        try
        {
            for (String eachDependOn: dependOns) 
            {
                if (eachDependOn != null) 
                {
                    atleastOneDependOnExists = true;
                    break;
                }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return atleastOneDependOnExists;
    }
    
    /**
     * This method checks whether all objects have Migration Sequence filled or not
     * @param migrationSequences
     * @return migrationSequenceIsNotCompletelyFilled
     * @author vkodapaka
     */
    public boolean checkMigrationSequenceIsCompletelyFilled(ArrayList<Double> migrationSequences)
    {
        boolean migrationSequenceIsNotCompletelyFilled = false;
        try
        {
            for (Double eachMigrationSequence: migrationSequences) 
            {
                if (eachMigrationSequence == null) 
                {
                    migrationSequenceIsNotCompletelyFilled = true;
                    break;
                }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return migrationSequenceIsNotCompletelyFilled;
    }
    
    /**
     * This method checks whether are there any duplicates in Migration Sequence
     * @param migrationSequences
     * @return hasDuplicateMigrationSequence
     * @author vkodapaka
     */
    public boolean checkDuplicatesInMigrationSequence(ArrayList<Double> migrationSequences) 
    {
        boolean hasDuplicateMigrationSequence = false;
        try
        {
            Set<Double> setToCheckDuplicates = new HashSet<Double>();
            for (Double eachMigraitonSequence : migrationSequences) 
            {
                if (!setToCheckDuplicates.add(eachMigraitonSequence)) 
                {
                    hasDuplicateMigrationSequence = true;
                }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return hasDuplicateMigrationSequence;
    }
    
    /**
     * This method checks whether all configured Depend Ons are available in Migration Sequence or not
     * @param migrationSequences
     * @param dependOns
     * @return dependOnIsNotAvailableInMigrationSequence
     * @author vkodapaka
     */
    public boolean checkAllDependOnsAreAvailableInMigrationSequence(ArrayList<Double> migrationSequences, ArrayList<String> dependOns)
    {
        boolean dependOnIsNotAvailableInMigrationSequence = true;
        try
        {
            int numberOfObjects = dependOns.size();
            String eachDependOn = null;
            for(int eachObjectIndex = 0; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                eachDependOn = dependOns.get(eachObjectIndex);
                if(dependOnIsNotAvailableInMigrationSequence && eachDependOn != null && !eachDependOn.isEmpty())
                {
                    String[] commaSeparatedDependOns = eachDependOn.split(",");
                    String eachCommaSeparatedDependOn = null;
                    int commaSeparatedDependOnsLength = commaSeparatedDependOns.length;
                    for(int eachCommaSeparatedDependOnIndex = 0; eachCommaSeparatedDependOnIndex < commaSeparatedDependOnsLength; eachCommaSeparatedDependOnIndex ++)
                    {
                        eachCommaSeparatedDependOn = commaSeparatedDependOns[eachCommaSeparatedDependOnIndex];
                        if(dependOnIsNotAvailableInMigrationSequence && eachCommaSeparatedDependOn != null && !eachCommaSeparatedDependOn.isEmpty())
                        {
                            if(migrationSequences.contains(Double.valueOf(eachCommaSeparatedDependOn)))
                            {
                                dependOnIsNotAvailableInMigrationSequence = true;
                            }
                            else
                            {
                                dependOnIsNotAvailableInMigrationSequence = false;
                                break;
                            }
                        }
                    }
                }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return dependOnIsNotAvailableInMigrationSequence;
    }
    
    /**
     * This method checks are there any deadlocks or not
     * (same object shouldn't be configured as Depend On)
     * @param migrationSequences
     * @param dependOns
     * @return noDeadLock
     * @author vkodapaka
     */
    public boolean checkIfSameObjectProvidedAsDependOn(ArrayList<Double> migrationSequences, ArrayList<String> dependOns)
    {
        boolean sameObjectIsNotProvidedAsDependOn = true;
        try
        {
            int numberOfObjects = dependOns.size();
            String eachDependOn = null;
            Double eachMigrationSequence = null;
            for(int eachObjectIndex = 0; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                eachDependOn = dependOns.get(eachObjectIndex);
                eachMigrationSequence = migrationSequences.get(eachObjectIndex);
                if(sameObjectIsNotProvidedAsDependOn && eachDependOn != null && !eachDependOn.isEmpty())
                {
                    String[] commaSeparatedDependOns = eachDependOn.split(",");
                    String eachCommaSeparatedDependOn = null;
                    int commaSeparatedDependOnsLength = commaSeparatedDependOns.length;
                    for(int eachCommaSeparatedDependOnIndex = 0; eachCommaSeparatedDependOnIndex < commaSeparatedDependOnsLength; eachCommaSeparatedDependOnIndex ++)
                    {
                        eachCommaSeparatedDependOn = commaSeparatedDependOns[eachCommaSeparatedDependOnIndex];
                        if(sameObjectIsNotProvidedAsDependOn && eachCommaSeparatedDependOn != null && !eachCommaSeparatedDependOn.isEmpty())
                        {
                            if(sameObjectIsNotProvidedAsDependOn && eachMigrationSequence != null
                                    && eachMigrationSequence.compareTo(Double.valueOf(eachCommaSeparatedDependOn)) == 0)
                            {
                                sameObjectIsNotProvidedAsDependOn = false;
                                break;
                            }
                            else
                            {
                                sameObjectIsNotProvidedAsDependOn = true;
                            }
                        }
                    }
                }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return sameObjectIsNotProvidedAsDependOn;
    }
    
    /**
     * This method checks whether first object(least migration sequence) has Depend on or not
     * @param migrationSequences
     * @param dependOns
     * @return firstObjectShouldNotHaveDependOn
     * @author vkodapaka
     */
    public boolean checkFirstObjectShouldNotHaveDependOn(ArrayList<Double> migrationSequences, ArrayList<String> dependOns)
    {
        boolean firstObjectShouldNotHaveDependOn = false;
        try
        {
            int numberOfObjects = dependOns.size();
            HashMap migrationSequencesAndDependOnsMap = new HashMap();
            for(int eachObjectIndex = 0; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                migrationSequencesAndDependOnsMap.put(Double.valueOf(migrationSequences.get(eachObjectIndex)), dependOns.get(eachObjectIndex));
            }
            
            ArrayList<Double> migrationSequencesDouble = new ArrayList<Double>();
            
            for(int eachObjectIndex = 0; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                migrationSequencesDouble.add(Double.valueOf(migrationSequences.get(eachObjectIndex)));
            }
            
            Collections.sort(migrationSequencesDouble);
            
            Double leastMigrationSequence = migrationSequencesDouble.get(0);
            
            String dependOnConfiguredForLeastMigrationSequence = null;
            
            if(migrationSequencesAndDependOnsMap != null && migrationSequencesAndDependOnsMap.size() > 0)
            {
                dependOnConfiguredForLeastMigrationSequence = (String) migrationSequencesAndDependOnsMap.get(leastMigrationSequence);
            }
            if(dependOnConfiguredForLeastMigrationSequence != null && !dependOnConfiguredForLeastMigrationSequence.isEmpty())
            {
                firstObjectShouldNotHaveDependOn = true;
            }
            else
            {
                firstObjectShouldNotHaveDependOn = false;
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return firstObjectShouldNotHaveDependOn;
    }
    
    /**
     * This method checks whether any higher migration sequence is configured as Depend On to stop deadlock situation
     * @param migrationSequences
     * @param dependOns
     * @return firstObjectShouldNotHaveDependOn
     * @author vkodapaka
     */
    public boolean checkObjectsDontHaveHigherMigrationSequenceAsDependOn(ArrayList<Double> migrationSequences, ArrayList<String> dependOns)
    {
        boolean objectsDontHaveHigherMigrationSequenceAsDependOn = true;
        try
        {
            int numberOfObjects = dependOns.size();
            HashMap migrationSequencesAndDependOnsMap = new HashMap();
            for(int eachObjectIndex = 0; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                migrationSequencesAndDependOnsMap.put(Double.valueOf(migrationSequences.get(eachObjectIndex)), dependOns.get(eachObjectIndex));
            }
            
            ArrayList<Double> migrationSequencesDouble = new ArrayList<Double>();
            
            for(int eachObjectIndex = 0; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                migrationSequencesDouble.add(Double.valueOf(migrationSequences.get(eachObjectIndex)));
            }
            
            Collections.sort(migrationSequencesDouble);
            
            Double eachMigrationSequence = null;
            for(int eachObjectIndex = 1; eachObjectIndex < numberOfObjects; eachObjectIndex ++)
            {
                eachMigrationSequence = migrationSequencesDouble.get(eachObjectIndex);
                String eachDependOn = (String) migrationSequencesAndDependOnsMap.get(eachMigrationSequence);
                if(objectsDontHaveHigherMigrationSequenceAsDependOn && eachDependOn != null && !eachDependOn.isEmpty())
                {
                    String[] commaSeparatedDependOns = eachDependOn.split(",");
                    String eachCommaSeparatedDependOn = null;
                    int commaSeparatedDependOnsLength = commaSeparatedDependOns.length;
                    for(int eachCommaSeparatedDependOnIndex = 0; eachCommaSeparatedDependOnIndex < commaSeparatedDependOnsLength; eachCommaSeparatedDependOnIndex ++)
                    {
                        eachCommaSeparatedDependOn = commaSeparatedDependOns[eachCommaSeparatedDependOnIndex];
                        if(objectsDontHaveHigherMigrationSequenceAsDependOn && eachCommaSeparatedDependOn != null && !eachCommaSeparatedDependOn.isEmpty())
                        {
                            if(eachMigrationSequence.compareTo(Double.valueOf(eachCommaSeparatedDependOn)) > 0)
                            {
                                objectsDontHaveHigherMigrationSequenceAsDependOn = true;
                            }
                            else
                            {
                                objectsDontHaveHigherMigrationSequenceAsDependOn = false;
                                break;
                            }
                        }
                    }
                }
            }
            
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return objectsDontHaveHigherMigrationSequenceAsDependOn;
    }
    
    /*
     * IS091765 - Automate Idempiere pack in process through migration tool (AOM)
     */
    public boolean isIdempierePackInObject(String objectType)
    {
    	boolean isIdempierePackInObject = false;
    	
    	if(objectType.equals("IDEMPIERE_APPLICATION/MODULE") 
    			|| objectType.equals("IDEMPIERE_CODE_SNIPIT") 
    			|| objectType.equals("IDEMPIERE_DATA") 
    			|| objectType.equals("IDEMPIERE_DYNAMIC_VALIDATION_RULE") 
    			|| objectType.equals("IDEMPIERE_ENTITY_TYPE") 
    			|| objectType.equals("IDEMPIERE_FILE") 
    			|| objectType.equals("IDEMPIERE_FORM") 
    			|| objectType.equals("IDEMPIERE_IMPORT_FORMAT") 
    			|| objectType.equals("IDEMPIERE_MESSAGE") 
    			|| objectType.equals("IDEMPIERE_MODEL_VALIDATOR") 
    			|| objectType.equals("IDEMPIERE_PRINTFORMAT") 
    			|| objectType.equals("IDEMPIERE_PROCESS/REPORT") 
    			|| objectType.equals("IDEMPIERE_REFERENCE") 
    			|| objectType.equals("IDEMPIERE_REPORTVIEW") 
    			|| objectType.equals("IDEMPIERE_ROLE") 
    			|| objectType.equals("IDEMPIERE_SQL_STATEMENT") 
    			|| objectType.equals("IDEMPIERE_TABLE") 
    			|| objectType.equals("IDEMPIERE_WINDOW") 
    			|| objectType.equals("IDEMPIERE_WORKFLOW"))
    	{
    		isIdempierePackInObject = true;
    	}

    	return isIdempierePackInObject;
    }
    
    public StringBuffer checkMissingForInformatica(SG_TRI2_MIG_INFORMATICA_OBJECTS mapInformaticaObject)
    {
    	StringBuffer fieldsRequired =  new StringBuffer();
    	
    	if(isEmpty(mapInformaticaObject.getsourceInstanceName()))
    		fieldsRequired.append("Source Instance,");

    	if(isEmpty(mapInformaticaObject.getsourceInstanceRepositoryDomain()))
    		fieldsRequired.append("Repository Domain,");

    	if(isEmpty(mapInformaticaObject.getsourceRepositoryName()))
    		fieldsRequired.append("Repository,");

    	if(isEmpty(mapInformaticaObject.getobjectType()))
    		fieldsRequired.append("Object Type,");

    	if(isEmpty(mapInformaticaObject.getsourceFolderName()))
    		fieldsRequired.append("Source Folders,");

    	if(isEmpty(mapInformaticaObject.gettargetInstanceRepositoryDomain()))
    		fieldsRequired.append("Target Repository Domain,");

    	if(isEmpty(mapInformaticaObject.gettargetRepository()))
    		fieldsRequired.append("Target Repository,");

    	if(isEmpty(mapInformaticaObject.gettargetFolderName()))
    		fieldsRequired.append("Target Folder,");
    	
    	int indexToRemove;
    	
    	if(!isEmpty(fieldsRequired.toString()))
		{
    		indexToRemove = fieldsRequired.lastIndexOf(",");
    		
    		if(indexToRemove != -1)
    		{
    			if((fieldsRequired.length() -1) == indexToRemove)
        		{
        			fieldsRequired.deleteCharAt(indexToRemove);
        		}
    		}
		}
        	
    	return fieldsRequired;
    }
    
    private boolean isEmpty(String args)
    {
        boolean returnVal = false;
        if(args == null)
        {
            returnVal = true;
        }
        else if(args.trim().length() == 0)
        {
            returnVal = true;
        }
        return returnVal;
    }
    
    
    private Object getThePropertyValueOrCheckingPatternForAOLObject(String resourceBundle, String propKeyOrObjectType, boolean flag)
    {
        System.out.println("Tri2ModelValidator.getThePropertyValueOrCheckingPatternForAOLObject()...is in Execution!");
        long startTime = System.currentTimeMillis();
        String outputDataMapFromServlet = null;
        HashMap patternValue = new HashMap();
        URL migrationServlet = null;
        URLConnection migrationServletConnection = null;
        ObjectOutputStream outputToServletStream = null;
        ObjectInputStream outputFromServletStream = null;
        FunctionHelper functionHelper = new FunctionHelper();
        Map<String, Object> parametersMap  = new HashMap<String, Object>();
        ArrayList<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
        try
        {
        	if(functionHelper != null)
        	{
        		if(flag)
        		{
        			parametersMap.put("objectTypePattern", propKeyOrObjectType);
                    list.add(parametersMap);
            		functionHelper.setFunctionName("patternPresentOrNotForTheAOLObjectType");
            		functionHelper.setParameterList(list);
        		}
        		else
        		{
        			parametersMap.put("propertyKey", propKeyOrObjectType);
                    list.add(parametersMap);
            		functionHelper.setFunctionName("getPropertyValueFromTRI2");
            		functionHelper.setParameterList(list);
        		}
        		
        	}
            migrationServlet = new URL(resourceBundle);
            System.out.println("Tri2ModelValidator.getThePropertyValueOrCheckingPatternForAOLObject()..resourceBundle! " + resourceBundle);
            migrationServletConnection = migrationServlet.openConnection();

            migrationServletConnection.setDoInput(true);
            migrationServletConnection.setDoOutput(true);
            migrationServletConnection.setUseCaches(false);
            migrationServletConnection.setDefaultUseCaches(false);
            migrationServletConnection.setRequestProperty("Content-Type", "application/x-java-serialized-object");

            outputToServletStream = new ObjectOutputStream(migrationServletConnection.getOutputStream());
            outputToServletStream.writeObject(functionHelper);
            outputToServletStream.flush();
            outputToServletStream.close();

            outputFromServletStream = new ObjectInputStream(migrationServletConnection.getInputStream());
            if(flag)
            {
            	patternValue = (HashMap) outputFromServletStream.readObject();

            }
            else
            {
            	outputDataMapFromServlet = (String) outputFromServletStream.readObject();
            }
            outputFromServletStream.close();
            System.out.println("Tri2ModelValidator.getThePropertyValueOrCheckingPatternForAOLObject()...patternValue ::"  + patternValue);
            System.out.println("Tri2ModelValidator.getThePropertyValueOrCheckingPatternForAOLObject()...outputDataMapFromServlet ::"  + outputDataMapFromServlet);
        }
        catch(java.net.ConnectException netException)
        {
            netException.printStackTrace();
        }
        catch(java.net.SocketException se)
        {
            se.printStackTrace();
        }
        catch(Exception exp)
        {
            exp.printStackTrace();
        }

        finally
        {
            migrationServlet = null;
            migrationServletConnection = null;
            outputToServletStream = null;
            outputFromServletStream = null;
        }
        long endTime = System.currentTimeMillis();
        System.out.println("Tri2ModelValidator.getThePropertyValueOrCheckingPatternForAOLObject()(ENDS) : endTime - startTime) " + (endTime - startTime) + " ms.");
        if(flag)
        {
        	return patternValue;
        }
        else
        {
        return outputDataMapFromServlet;
        }
    }
    
    private String changeTicketToIncident(String resourceBundle)
    {
        System.out.println("Tri2ModelValidator.changeTicketToIncident()...is in Execution!");
        long startTime = System.currentTimeMillis();
        String outputDataMapFromServlet = null;
        URL migrationServlet = null;
        URLConnection migrationServletConnection = null;
        ObjectOutputStream outputToServletStream = null;
        ObjectInputStream outputFromServletStream = null;
        FunctionHelper functionHelper = new FunctionHelper();
        Map<String, Object> parametersMap  = new HashMap<String, Object>();
        ArrayList<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
        try
        {
        	if(functionHelper != null)
        	{
        		parametersMap.put("propertyKey", "ticketAlias");
                list.add(parametersMap);
        		functionHelper.setFunctionName("getPropertyValueFromTRI2");
        		functionHelper.setParameterList(list);
        	}
            migrationServlet = new URL(resourceBundle);
            System.out.println("Tri2ModelValidator.changeTicketToIncident()..resourceBundle! " + resourceBundle);
            migrationServletConnection = migrationServlet.openConnection();

            migrationServletConnection.setDoInput(true);
            migrationServletConnection.setDoOutput(true);
            migrationServletConnection.setUseCaches(false);
            migrationServletConnection.setDefaultUseCaches(false);
            migrationServletConnection.setRequestProperty("Content-Type", "application/x-java-serialized-object");

            outputToServletStream = new ObjectOutputStream(migrationServletConnection.getOutputStream());
            outputToServletStream.writeObject(functionHelper);
            outputToServletStream.flush();
            outputToServletStream.close();

            outputFromServletStream = new ObjectInputStream(migrationServletConnection.getInputStream());
            outputDataMapFromServlet = (String) outputFromServletStream.readObject();
            outputFromServletStream.close();

            System.out.println("Tri2ModelValidator.changeTicketToIncident()...outputDataMapFromServlet ::"  + outputDataMapFromServlet);
        }
        catch(java.net.ConnectException netException)
        {
            netException.printStackTrace();
        }
        catch(java.net.SocketException se)
        {
            se.printStackTrace();
        }
        catch(Exception exp)
        {
            exp.printStackTrace();
        }

        finally
        {
            migrationServlet = null;
            migrationServletConnection = null;
            outputToServletStream = null;
            outputFromServletStream = null;
        }
        long endTime = System.currentTimeMillis();
        System.out.println("Tri2ModelValidator.changeTicketToIncident()(ENDS) : endTime - startTime) " + (endTime - startTime) + " ms.");
        return outputDataMapFromServlet;
    }
    private boolean isAOLObject(String objectType)
    {
    	System.out.println("Tri2ModelValidator.isAOLObject() is calling objectType::" + objectType);
    	//IS105852 - Added all the AOL objects to the condition to check for the keyword validations
    	if(objectType.equalsIgnoreCase("CONCURRENT_PROGRAM_NAME")
        		 || objectType.equalsIgnoreCase("REQUEST_GROUP_NAME")
                 || objectType.equalsIgnoreCase("REQUEST_SET_NAME")
                 || objectType.equalsIgnoreCase("REQUEST_SET_LINK_NAME")
                 || objectType.equalsIgnoreCase("FLEX_VALUE_SET_NAME")
                 || objectType.equalsIgnoreCase("DESCRIPTIVE_FLEXFIELD_NAME")
                 || objectType.equalsIgnoreCase("PROFILE_NAME")
                 || objectType.equalsIgnoreCase("MENU_NAME")
                 || objectType.equalsIgnoreCase("PRINTER_STYLE_NAME")
                 || objectType.equalsIgnoreCase("LOOKUP_TYPE")
                 || objectType.equalsIgnoreCase("FORM_NAME")
                 || objectType.equalsIgnoreCase("ID_FLEX_CODE")
                 || objectType.equalsIgnoreCase("BNE_LAYOUTS")
                 || objectType.equalsIgnoreCase("EXECUTABLE_NAME")
                 || objectType.equalsIgnoreCase("FND_USER_NAME")
                 || objectType.equalsIgnoreCase("XML_PUB_REPORTS")
                 || objectType.equalsIgnoreCase("XDO_DS_DEFINITIONS")
                 || objectType.equalsIgnoreCase("ORACLE_WORKFLOW")
                 || objectType.equalsIgnoreCase("FUNCTION_NAME")
                 || objectType.equalsIgnoreCase("BNE_PARAMLIST")
                 || objectType.equalsIgnoreCase("FND_FORM_FUNCTION_NAME")
                 || objectType.equalsIgnoreCase("INTEGRATION_REPOSITORY_OBJECT")
                 || objectType.equalsIgnoreCase("COLLECTION_PLAN")
                 || objectType.equalsIgnoreCase("COLLECTION_ELEMENT")
                 || objectType.equalsIgnoreCase("AME_ATTRIBUTE")
                 || objectType.equalsIgnoreCase("AME_ATTRIBUTE_USAGES")
                 || objectType.equalsIgnoreCase("AME_ATTRIBUTE_CONDITIONS")
                 || objectType.equalsIgnoreCase("AME_APPROVAL_GROUPS")
                 || objectType.equalsIgnoreCase("AME_APPROVAL_GROUP_CONFIG")
                 || objectType.equalsIgnoreCase("AME_RULES")
                 || objectType.equalsIgnoreCase("AME_RULE_ACTION_TYPE_USAGES")
                 || objectType.equalsIgnoreCase("BNE_MAPPINGS")
                 || objectType.equalsIgnoreCase("BNE_CONTENTS")
                 || objectType.equalsIgnoreCase("BNE_INTEGRATORS")
                 || objectType.equalsIgnoreCase("DISCOVERER_BA_FOLDER")
                 || objectType.equalsIgnoreCase("ALERT_NAME")
                 || objectType.equalsIgnoreCase("FLEX_VALUE_SET_VALUE_NAME")
                 || objectType.equalsIgnoreCase("MESSAGE_NAME")
                 || objectType.equalsIgnoreCase("DISCOVERER_REPORTS")
                 || objectType.equalsIgnoreCase("FND_ATTACHMENT_FUNCTIONS"))
        {
            return true;
        }
        System.out.println("Tri2ModelValidator.isAOLObject() is called");
        return false;
    }
    
    /***
     * @author khusboo.kumari
     * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
     */
    public ArrayList onSuccessOnFailureValidation(ArrayList<Double> migrationSequences, ArrayList<Double> onSuccesses, ArrayList<Double> onFailures, HashMap successMap, HashMap failureMap)
    {
        System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation()...is in Execution!");
        System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() migrationSequences : " + migrationSequences + ", onSuccesses : " + onSuccesses +
        		", onFailures : " + onFailures +"successMap : " + successMap + "failureMap : " + failureMap);
        long startTime = System.currentTimeMillis();
        boolean validationFlag = true;
        String  validationErrorMessage = null;
        ArrayList validationList = null;
        try
        {
            boolean atleastOneOnSuccessOrOnFailureExists = false;
            if(migrationSequences.size() == onSuccesses.size() && migrationSequences.size() == onFailures.size())
            {
            	atleastOneOnSuccessOrOnFailureExists = containsAtleastOneOnSuccessOrOnFailure(onSuccesses, onFailures);
            	System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() atleastOneOnSuccessOrOnFailureExists : " + atleastOneOnSuccessOrOnFailureExists);
                boolean migrationSequenceIsNotCompletelyFilled = false;
                if(atleastOneOnSuccessOrOnFailureExists)
                {
                    /**
                     * 1. 'Migration Sequence' should be filled for all objects.
                     */
                    migrationSequenceIsNotCompletelyFilled = checkMigrationSequenceIsCompletelyFilled(migrationSequences);
                    System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() migrationSequenceIsNotCompletelyFilled : " + migrationSequenceIsNotCompletelyFilled);
                    boolean hasDuplicateMigrationSequence = false;
                    if(migrationSequenceIsNotCompletelyFilled)
                    {
                        validationFlag = false;
                        validationErrorMessage = "'Migration Sequence' should be filled for all objects.";
                    }
                    else
                    {
                        /**
                         * 2. Duplicates are not allowed in 'Migration Sequence' column.
                         */
                        hasDuplicateMigrationSequence = checkDuplicatesInMigrationSequence(migrationSequences);
                        System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() hasDuplicateMigrationSequence : " + hasDuplicateMigrationSequence);
                        if(hasDuplicateMigrationSequence)
                        {
                            validationFlag = false;
                            validationErrorMessage = "Duplicates are not allowed in 'Migration Sequence' column.";
                        }
                        else
                        {
                            /**
                             * 3. Provided 'onSuccess Or OnFailure' value(s) is/are not available in 'Migration Sequence' column.
                             */
                        	Boolean onSuccessOrOnFailureIsNotAvailableInMigrationSequence = checkAllonSuccessOrOnFailuresAreAvailableInMigrationSequence(migrationSequences, onSuccesses, onFailures);
                        	System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() onSuccessOrOnFailureIsNotAvailableInMigrationSequence : "+ onSuccessOrOnFailureIsNotAvailableInMigrationSequence);
                            boolean checkDeadlock = false;
                            boolean firstObjectShouldHaveInOnSuccessOnFailure = false;
                            if(!onSuccessOrOnFailureIsNotAvailableInMigrationSequence)
                            {
                                validationFlag = false;
                                validationErrorMessage = "Provided 'onSuccesses Or OnFailure' value(s) is/are not available in 'Migration Sequence' column.";
                            }
                            else
                            {
                            	/**
                            	 * 4. Check the On Success or OnFailure value available in First Row.
                            	 */
                            	firstObjectShouldHaveInOnSuccessOnFailure = checkFirstOnSuccessOrOnFailureValueAvailable(migrationSequences, onSuccesses, onFailures);
                            	System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() firstObjectShouldHaveInOnSuccessOnFailure : " + firstObjectShouldHaveInOnSuccessOnFailure);
                            	if(!firstObjectShouldHaveInOnSuccessOnFailure)
                            	{
                            		validationFlag = false;
                            		validationErrorMessage = "OnSuccess Or OnFailure value must be available in First row.";
                            	}
                            	/**
                            	 * 5. Check the Deadlock
                            	 */
                            	else 
                            	{
                            		int sequenceNumbersListSize = migrationSequences.size();
                            		System.out.println("Tri2ModelValidator.onSuccessOnFailureValidation() sequenceNumbersListSize : " + sequenceNumbersListSize);
                            		if(sequenceNumbersListSize != 0) 
                            		{
                            			Collections.sort(migrationSequences);
                            			ArrayList parentsList = new ArrayList();
                            			Double root = migrationSequences.get(0);
                            			parentsList.add(root);
                            			if (!checkDeadLock(root, parentsList, successMap, failureMap)) {
                            				validationFlag = false;
                            				validationErrorMessage = "Deadlock Occured at Sequence Number : ";
                            				if(deadLockOccurredList != null && !deadLockOccurredList.isEmpty())
                            				{
                            					for(Double value : deadLockOccurredList) 
                            					{
                            						if(value != null)
                            						{
                            							validationErrorMessage = validationErrorMessage + "[" + value.intValue() + "]" + "  ";
                            						}
                            					}
                            				}
                            			}
                            			else
                            			{
                            				System.out.println("Not Deadlock Occured");
                            			}
                            		}
                            	}
                            }
                        }
                    }
                }
            }
            else
            {
                validationFlag = false;
                validationErrorMessage = "Configured Migration Sequences and onSuccesses or onFailures are not of same size.";
            }
        }
        catch(Exception e)
        {
            validationFlag = false;
            e.printStackTrace();
        }
        finally
        {
            validationList = new ArrayList();
            validationList.add(validationFlag);
            validationList.add(validationErrorMessage);
        }
        System.out.println("DependOnValidation.dependOnValidation()...validationList:" + validationList);
        long endTime = System.currentTimeMillis();
        System.out.println("Tri2ModelValidator.dependOnValidation()(ENDS) : endTime - startTime):" + (endTime - startTime) + " ms.");
        return validationList;
    }

    /***
     * @author khusboo.kumari
     * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
     */
	public boolean containsAtleastOneOnSuccessOrOnFailure(ArrayList<Double> onSuccesses, ArrayList<Double> onFailures)
    {
        try
        {
        	if((onSuccesses == null || onSuccesses.isEmpty()) && (onFailures == null ||onFailures.isEmpty())) 
        	{
        		return false;
        	}
        	if(onSuccesses != null && !onSuccesses.isEmpty())
        	{
        		for (Double onSuccess : onSuccesses) 
        		{
        			if (onSuccess != null) 
        			{
        				return true;
        			}
        		}
        	}
        	if(onFailures != null && !onFailures.isEmpty()) 
        	{  
        		for (Double onFailure : onFailures) 
	            {
	                if (onFailure != null) 
	                {
	                    return true;
	                }
	            }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return false;
    }
	/***
     * @author khusboo.kumari
     * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
     */
    public boolean checkAllonSuccessOrOnFailuresAreAvailableInMigrationSequence(ArrayList<Double> migrationSequences,ArrayList<Double> onSuccesses, ArrayList<Double> onFailures)
    {
        try
        {
        	for(Double onSuccess : onSuccesses) 
        	{
        			if( onSuccess != null && !migrationSequences.contains(onSuccess))
        			{
        				return false;
        			}
        	}
        	for(Double onFailure : onFailures) 
        	{
        			if(onFailure != null && !migrationSequences.contains(onFailure))
        			{
        				return false;
        			}
        	}
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return true;
    }
    /***
     * @author khusboo.kumari
     * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
     */
    public boolean checkDeadLock(Double a, ArrayList<Double> parentsList, HashMap successMap, HashMap failureMap) 
    {
    	System.out.println("Tri2ModelValidator.checkDeadLock() Integer : "+ a + "parentsList : " + parentsList +
    			"successMap : " + successMap + "failureMap : " + failureMap);
    	Double successChild = (Double) successMap.get(a);
    	Double failureChild = (Double) failureMap.get(a);
    	System.out.println("Tri2ModelValidator.checkDeadLock() successChild :" + successChild +"failureChild : " + failureChild);

		if (successChild != null) 
		{
			ArrayList tempList = new ArrayList();
			tempList.addAll((ArrayList) parentsList.clone());
			if (parentsList.contains(successMap.get(a))) 
			{
				if(deadLockOccurredList != null)
				{
					deadLockOccurredList.add(a);
					deadLockOccurredList.add(successChild);
				}
				return false;
			}
			tempList.add(successChild);
			System.out.println("Tri2ModelValidator.checkDeadLock() tempList : "+ tempList);

			if (!checkDeadLock(successChild, tempList, successMap, failureMap)) 
			{
				return false;
			}
		}
		if (failureChild != null) 
		{
			ArrayList tempList = new ArrayList();
			tempList.addAll((ArrayList) parentsList.clone());
			if (parentsList.contains(failureMap.get(a))) 
			{
				if(deadLockOccurredList != null)
				{
					deadLockOccurredList.add(a);
					deadLockOccurredList.add(failureChild);
				}
				return false;
			}

			tempList.add(failureChild);
			System.out.println("Tri2ModelValidator.checkDeadLock() tempList : "+ tempList);

			if (!checkDeadLock(failureChild, tempList, successMap, failureMap)) 
			{
				return false;
			}
		}
		return true;
    }
    /***
     * @author khusboo.kumari
     * IS112836 - Implement the On Success and On Failure functionality in AOM Tool.
     */
    private boolean checkFirstOnSuccessOrOnFailureValueAvailable(ArrayList<Double> migrationSequences,
			ArrayList<Double> onSuccesses, ArrayList<Double> onFailures)
    {
    	if(onSuccesses != null && !onSuccesses.isEmpty() && onSuccesses.get(0) != null)
    	{
    		return true;
    	}
    	if(onFailures != null && !onFailures.isEmpty() && onFailures.get(0) != null)
    	{
    		return true;
    	}

    	return false;
    }
}
